diff --git a/src/.vscode/launch.json b/src/.vscode/launch.json
new file mode 100644
index 0000000..445f95e
--- /dev/null
+++ b/src/.vscode/launch.json
@@ -0,0 +1,11 @@
+{
+    "configurations": [
+        {
+            "type": "java",
+            "name": "CodeLens (Launch) - Practica3",
+            "request": "launch",
+            "mainClass": "mx.unam.ciencias.edd.Practica3",
+            "projectName": "src_68f10cf9"
+        }
+    ]
+}
\ No newline at end of file
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index aec1cf8..d4f0d29 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -1,5 +1,6 @@
 package mx.unam.ciencias.edd;
 
+import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 /**
@@ -29,7 +30,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            padre = null;
+            izquierdo = null;
+            derecho = null;
         }
 
         /**
@@ -38,7 +42,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+            return padre != null;
         }
 
         /**
@@ -47,7 +51,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+            return izquierdo != null;
         }
 
         /**
@@ -56,7 +60,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+            return derecho != null;
         }
 
         /**
@@ -65,7 +69,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
         @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+            if (padre == null) throw new NoSuchElementException();
+            return padre;
         }
 
         /**
@@ -74,7 +79,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+            if (izquierdo == null) throw new NoSuchElementException();
+            return izquierdo;
         }
 
         /**
@@ -83,7 +89,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
         @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+            if (derecho == null) throw new NoSuchElementException();
+            return derecho;
         }
 
         /**
@@ -91,7 +98,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            if (hayIzquierdo() && hayDerecho()) {
+                return 1 + Math.max(izquierdo.altura(), derecho.altura());
+            } else if (hayIzquierdo()) {
+                return 1 + izquierdo.altura();
+            } else if (hayDerecho()) {
+                return 1 + derecho.altura();
+            } else {
+                return 0;
+            }
         }
 
         /**
@@ -99,7 +114,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
+            if (padre == null) return 0;
+            return 1 + padre.profundidad();
         }
 
         /**
@@ -107,7 +123,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+            return elemento;
         }
 
         /**
@@ -124,7 +140,26 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
+            return auxEquals(this,vertice);
+        }
+
+        /**
+         * Método auxiliar recursivo el cual recibe 2 vertices y revisa si sus subsecuentes
+         * son iguales.
+         * @param a vertice a comparar
+         * @param b vertice a comparar
+         */
+        private boolean auxEquals(Vertice a, Vertice b) {
+            if (a == null && b == null)
+                return true;
+            if (a != null && b != null) {
+                if (!a.elemento.equals(b.elemento))
+                    return false;
+                if (auxEquals(a.izquierdo, b.izquierdo))
+                    return auxEquals(a.derecho, b.derecho);
+                return false;
+            }
+            return false;
         }
 
         /**
@@ -132,7 +167,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+            String s = "";
+            return s + elemento.toString();
         }
     }
 
@@ -153,7 +189,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        coleccion.forEach((t) -> {agrega(t);});
     }
 
     /**
@@ -175,7 +211,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        if (elementos == 0) return -1;
+        else return raiz.altura();
     }
 
     /**
@@ -183,7 +220,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -193,7 +230,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (busca(elemento) == null)
+            return false;
+        else
+            return true;
     }
 
     /**
@@ -204,7 +245,27 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <tt>null</tt> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (esVacia()) return null;
+        return buscaAux(raiz(),elemento);
+    }
+
+    /**
+     * Método auxiliar que busca un elemento en todos los nodos de la izquierda 
+     * y de la derecha recursivamente.
+     * @param v vertice a comparar con el elemento.
+     * @param elemento elemento a comparar con los vertices del árbol.
+     */
+    private VerticeArbolBinario<T> buscaAux(VerticeArbolBinario<T> v, T elemento) {
+        if (v.get().equals(elemento))
+            return v;
+        if (v.hayIzquierdo())
+            if ((buscaAux(v.izquierdo(), elemento)) != null) 
+                return (buscaAux(v.izquierdo(), elemento));
+        if (v.hayDerecho())
+            if ((buscaAux(v.derecho(), elemento)) != null) 
+                return (buscaAux(v.derecho(), elemento));
+        return null;
     }
 
     /**
@@ -213,7 +274,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+        if (esVacia()) throw new NoSuchElementException();
+        return raiz;
     }
 
     /**
@@ -222,14 +284,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        raiz = null;
+        elementos = 0;
     }
 
     /**
@@ -242,8 +305,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked")
-            ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+        ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
+        if (esVacia() && arbol.esVacia()) return true;
+        else return raiz.equals(arbol.raiz);
     }
 
     /**
@@ -251,7 +315,63 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if (raiz == null) return "";
+        int a [] = new int[altura() + 1];
+        for (int i = 0; i < altura() + 1; i++) {
+            a[i] = 0;
+        }
+        return cadena(raiz, 0, a);
+    }
+
+    /**
+     * Método auxiliar que maneja los niveles del árbol para ilustrar en la cadena,
+     * el significado de los simbolos es: con una '>' es el izquierdo, con dos '>>' es el
+     * derecho.
+     * @param v vertice el cual se imprime su elemento.
+     * @param nivel el nivel del arbol el cual imprime los elementos.
+     * @param a arreglo de 0 y 1.
+     */
+    private String cadena(Vertice v, int nivel, int[] a){
+        String s = v.toString() + "\n";
+        a[nivel] = 1;
+        if (v.hayIzquierdo() && v.hayDerecho()) {
+            s = s + dibujaEspacios(nivel,a);
+            s = s + "├─›";
+            s = s + cadena(v.izquierdo, nivel + 1, a);
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─»";
+            a[nivel] = 0;
+            s = s + cadena(v.derecho, nivel + 1, a);
+        } else if (v.hayIzquierdo()) {
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─›";
+            a[nivel] = 0;
+            s = s + cadena(v.izquierdo, nivel + 1, a);
+        } else if (v.hayDerecho()) {
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─»";
+            a[nivel] = 0;
+            s = s + cadena(v.derecho, nivel + 1, a);
+        }
+        return s;
+    }
+
+    /**
+     * Método auxiliar que dibuja los espacios correspondientes para la representación
+     * en cadena del árbol.
+     * @param nivel el nivel del arbol el cual imprime los elementos.
+     * @param a arreglo de 0 y 1.
+     */
+    private String dibujaEspacios(int nivel, int[] a){
+        String s = "";
+        for (int i = 0; i <= nivel - 1; i++) {
+            if (a[i] == 1) {
+                s = s + "│  ";
+            } else {
+                s = s + "   ";
+            }
+        }
+        return s;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 2015564..9079fdd 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -1,6 +1,7 @@
 package mx.unam.ciencias.edd;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * <p>Clase para árboles binarios completos.</p>
@@ -18,17 +19,24 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Constructor que recibe la raíz del árbol. */
         public Iterador() {
-            // Aquí va su código.
+            cola = new Cola<Vertice>();
+            if (raiz != null){
+                cola.mete(raiz);
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+            if (cola.esVacia()) throw new NoSuchElementException();
+            Vertice v = cola.saca();
+            if (v.hayIzquierdo()) cola.mete(v.izquierdo);
+            if (v.hayDerecho()) cola.mete(v.derecho);
+            return v.get();
         }
     }
 
@@ -56,7 +64,32 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        Vertice nuevo = nuevoVertice(elemento);        
+        elementos++;
+        if (esVacia()) raiz = nuevo;
+        else {
+            Cola<VerticeArbolBinario<T>> cola = new Cola<>();
+            cola.mete(raiz());
+            VerticeArbolBinario<T> v;
+            while (!cola.esVacia()) {
+                v = cola.saca();
+                if (v.hayIzquierdo()) cola.mete(v.izquierdo());
+                if (v.hayDerecho()) cola.mete(v.derecho());
+                if (!v.hayIzquierdo()) {
+                    Vertice a = vertice(v);
+                    a.izquierdo = nuevo;
+                    nuevo.padre = a;
+                    return;
+                }
+                if (!v.hayDerecho()) {
+                    Vertice b = vertice(v);
+                    b.derecho = nuevo;
+                    nuevo.padre = b;
+                    return;
+                }
+            }      
+        }
     }
 
     /**
@@ -66,7 +99,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (!contiene(elemento)) return;
+        elementos--;
+        if (elementos == 0) {
+            limpia();
+            return;
+        }
+        Cola<Vertice> cola = new Cola<>();
+        cola.mete(raiz);
+        Vertice ultimo = null;
+        while (!cola.esVacia()) {
+            ultimo = cola.saca();
+            if (ultimo.hayIzquierdo()) cola.mete(ultimo.izquierdo);
+            if (ultimo.hayDerecho()) cola.mete(ultimo.derecho);
+        }
+        Vertice e = vertice(busca(elemento));
+        e.elemento = ultimo.elemento;
+        Vertice padre = ultimo.padre;
+        if (padre.izquierdo == ultimo) {
+            padre.izquierdo = null;
+        } else {
+            padre.derecho = null;
+        }
     }
 
     /**
@@ -75,7 +130,8 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
-        // Aquí va su código.
+        if (raiz == null) return -1;
+        return (int)(Math.floor(Math.log(elementos) / Math.log(2)));
     }
 
     /**
@@ -84,7 +140,15 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (esVacia()) return;
+        Cola<VerticeArbolBinario<T>> cola = new Cola<>();
+        cola.mete(raiz());
+        while (!cola.esVacia()) {
+            VerticeArbolBinario<T> v = cola.saca();
+            accion.actua(v);
+            if (v.hayIzquierdo()) cola.mete(v.izquierdo());
+            if (v.hayDerecho()) cola.mete(v.derecho());
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index 690cb10..f319cd7 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -1,6 +1,7 @@
 package mx.unam.ciencias.edd;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * <p>Clase para árboles binarios ordenados. Los árboles son genéricos, pero
@@ -25,17 +26,32 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
         /* Construye un iterador con el vértice recibido. */
         public Iterador() {
-            // Aquí va su código.
+            pila = new Pila<Vertice>();
+            if (raiz != null) {
+                pila.mete(raiz);
+                Vertice aux = raiz;
+                while (aux.hayIzquierdo()){
+                    pila.mete(aux.izquierdo);
+                    aux = aux.izquierdo;
+                }
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice aux = pila.saca();
+            T t = aux.get();
+            aux = aux.derecho;
+            while (aux != null){
+                pila.mete(aux);
+                aux = aux.izquierdo;
+            }
+            return t;
         }
     }
 
@@ -69,7 +85,39 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        Vertice nuevo = nuevoVertice(elemento);
+        elementos++;
+        if (raiz == null) {
+            raiz = nuevo;
+            ultimoAgregado = nuevo;
+            return;
+        } else {
+            auxAgrega(raiz, nuevo);
+            ultimoAgregado = nuevo;
+        }
+    }
+
+    /**
+     * Método auxiliar para recorrer el árbol de acuerdo a si el elemento es mayor,
+     * menor o igual y hasta encontrar una hoja colocarse allí, al final del árbol.
+     * @param actual Vertice con el cual se va a comparar, si es mayor, menor o igual.
+     * @param nuevo Vertice el cual se va a agregar al árbol.
+     */
+    private void auxAgrega(Vertice actual, Vertice nuevo){
+        if ((nuevo.get().compareTo(actual.get())) <= 0) {
+            if (!actual.hayIzquierdo()) {
+                actual.izquierdo = nuevo;
+                nuevo.padre = actual;
+                return;
+            } else auxAgrega(actual.izquierdo, nuevo);
+        } else {
+            if (!actual.hayDerecho()) {
+                actual.derecho = nuevo;
+                nuevo.padre = actual;
+                return;
+            } else auxAgrega(actual.derecho, nuevo);
+        }
     }
 
     /**
@@ -79,7 +127,16 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (busca(elemento) == null) return;
+        VerticeArbolBinario<T> e = busca(elemento);
+        Vertice aEliminar = vertice(e);
+        elementos--;
+        if (elementos == 0) limpia();
+        if (aEliminar.hayIzquierdo() && aEliminar.hayDerecho()) {
+            aEliminar = intercambiaEliminable(aEliminar);
+        }
+        eliminaVertice(aEliminar);
     }
 
     /**
@@ -92,7 +149,11 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         de <code>null</code>.
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        Vertice v = maximoEnSubArbol(vertice.izquierdo);
+        T t = v.get();
+        v.elemento = vertice.elemento;
+        vertice.elemento = t;
+        return v;
     }
 
     /**
@@ -102,7 +163,31 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *                distinto de <code>null</code>.
      */
     protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+        Vertice hijo = null;
+        Vertice padre = null;
+        if (vertice.hayIzquierdo()) hijo = vertice.izquierdo;
+        if (vertice.hayDerecho()) hijo = vertice.derecho;
+        if (vertice.hayPadre()) padre = vertice.padre;
+
+        if (padre != null) {
+            if (padre.izquierdo == vertice){ //Aqui estaba la falla :v
+                padre.izquierdo = hijo;
+            } else {
+                padre.derecho = hijo;
+            }
+        } else if (padre == null) raiz = hijo;
+        
+        if (hijo != null) hijo.padre = padre;
+
+    }
+
+    /**
+     * Te regresa el elemento máximo de un subarbol
+     * @param v vertice el cual es la raiz de un subarbol
+     */
+    private Vertice maximoEnSubArbol(Vertice v) {
+        if (!v.hayDerecho()) return v;
+        return maximoEnSubArbol(v.derecho);
     }
 
     /**
@@ -113,7 +198,31 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         encuentra; <tt>null</tt> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (esVacia()) return null;
+        return buscaAux(raiz(),elemento);
+    }
+
+    /**
+     * Método auxiliar que busca recursivamente el elemento, debido a que el árbol está
+     * ordenado si el elemento es mayor busca por la derecha, si es menor o igual busca
+     * por la izquierda, si llega a alguna hoja implica que no encontró el elemento y 
+     * regresa <tt>null</tt>.
+     * @param el elemento a buscar.
+     * @return vertice encontrado que contiene el elemento, <tt>null</tt> en otro caso.
+     */
+    private VerticeArbolBinario<T> buscaAux(VerticeArbolBinario<T> v, T elemento) {
+        if (elemento.compareTo(v.get()) == 0) 
+            return v;
+        else if (elemento.compareTo(v.get()) <= 0)
+            if (v.hayIzquierdo())
+                return buscaAux(v.izquierdo(), elemento);
+            else return null;
+        else if (elemento.compareTo(v.get()) > 0)
+            if (v.hayDerecho())
+                return buscaAux(v.derecho(), elemento);
+            else return null;
+        return null;
     }
 
     /**
@@ -137,7 +246,22 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (!vertice.hayIzquierdo() || vertice == null) return;
+        Vertice q = vertice(vertice);
+        Vertice p = q.izquierdo;
+        Vertice s = p.derecho;
+        p.derecho = q;
+        p.padre = q.padre;
+        q.izquierdo = s;
+        if (q.hayIzquierdo()) s.padre = q; //Verificamos si 's' existe
+        if (!p.hayPadre()) { //Preguntamos si 'q' es la raiz
+            raiz = p;
+            q.padre = p;
+            return;
+        }
+        if (q == q.padre.derecho) q.padre.derecho = p; //Ajustamos si el vertice es izq o derecho
+        else q.padre.izquierdo = p;                     //del padre
+        q.padre = p;
     }
 
     /**
@@ -146,7 +270,22 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (!vertice.hayDerecho()) return;
+        Vertice p = vertice(vertice);
+        Vertice q = p.derecho;
+        Vertice s = q.izquierdo;
+        q.izquierdo = p;
+        q.padre = p.padre;
+        p.derecho = s;
+        if (p.hayDerecho()) s.padre = p; //Verificamos si 's' existe
+        if (!q.hayPadre()) { //Preguntamos si 'p' es la raiz
+            raiz = q;
+            p.padre = q;
+            return;
+        }
+        if (p == p.padre.izquierdo) p.padre.izquierdo = q; //Ajustamos si el vertice es izquierdo o derecho
+        else p.padre.derecho = q;                     //del padre
+        p.padre = q;
     }
 
     /**
@@ -155,7 +294,18 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        auxDfsPreOrder(raiz(),accion);
+    }
+
+    /**
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS <em>pre-order</em>
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices del árbol.
+     * @param v Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsPreOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion){
+        accion.actua(v);
+        if (v.hayIzquierdo()) auxDfsPreOrder(v.izquierdo(), accion);
+        if (v.hayDerecho()) auxDfsPreOrder(v.derecho(), accion);
     }
 
     /**
@@ -164,7 +314,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (esVacia()) return;
+        auxDfsInOrder(raiz(), accion);
+    }
+
+    /**
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS <em>in-order</em>
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices del árbol.
+     * @param v Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsInOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion) {
+        if (v.hayIzquierdo()) auxDfsInOrder(v.izquierdo(), accion);
+        accion.actua(v);
+        if (v.hayDerecho()) auxDfsInOrder(v.derecho(), accion);
     }
 
     /**
@@ -173,7 +335,18 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        auxDfsPostOrder(raiz(), accion);
+    }
+
+    /**
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS <em>post-order</em>
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices del árbol.
+     * @param v Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsPostOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion) {
+        if (v.hayIzquierdo()) auxDfsPostOrder(v.izquierdo(), accion);
+        if (v.hayDerecho()) auxDfsPostOrder(v.derecho(), accion);
+        accion.actua(v);
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..38f313b 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -16,18 +16,40 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordenar el arreglo.
      */
-    public static <T> void
-    quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void quickSort(T[] arreglo, Comparator<T> comparador) {
+        quickSort(arreglo, 0, arreglo.length - 1, comparador);
+    }
+
+    
+    private static <T> void quickSort(T[] arreglo, int a, int b, Comparator<T> comparador) {
+        if (b <= a)
+            return;
+        int i = a + 1;
+        int j = b;
+        while (i < j) {
+            if ((comparador.compare(arreglo[i], arreglo[a]) > 0) && (comparador.compare(arreglo[j], arreglo[a])) <= 0) {
+                intercambia(arreglo, i, j);
+                i++;
+                j--;
+            } else if ((comparador.compare(arreglo[i], arreglo[a])) <= 0)
+                i++;
+            else
+                j--;
+        }
+        if (comparador.compare(arreglo[i], arreglo[a]) > 0) {
+            i--;
+        }
+        intercambia(arreglo, a, i);
+        quickSort(arreglo, a, i - 1, comparador);
+        quickSort(arreglo, i + 1, b, comparador);
     }
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    quickSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void quickSort(T[] arreglo) {
         quickSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -37,9 +59,17 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordernar el arreglo.
      */
-    public static <T> void
-    selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void selectionSort(T[] arreglo, Comparator<T> comparador) {
+        int m = 0;
+        for (int i = 0; i < arreglo.length; i++) {
+            m = i;
+            for (int j = i + 1; j < arreglo.length; j++) {
+                if ((comparador.compare(arreglo[j], arreglo[m])) < 0) {
+                    m = j;
+                }
+            }
+            intercambia(arreglo, i, m);
+        }
     }
 
     /**
@@ -47,8 +77,7 @@ public class Arreglos {
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    selectionSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void selectionSort(T[] arreglo) {
         selectionSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -61,9 +90,36 @@ public class Arreglos {
      * @param comparador el comparador para hacer la búsqueda.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T> int
-    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> int busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
+        return busquedaBinaria(0, arreglo.length - 1, arreglo, elemento, comparador);
+    }
+
+    /**
+     * Método auxiliar que parte el arreglo en 2 hasta encontrar el indice del
+     * elemento
+     * 
+     * @param init       Indice inicial del arreglo o del subarreglo
+     * @param fin        Indice final del arreglo o del subarreglo
+     * @param arreglo    El arreglo al que se le aplica la busqueda
+     * @param elemento   Elemento a buscar en el arreglo
+     * @param comparador Objeto que se usa para comparar los elementos internos del
+     *                   arreglo
+     * @return El indice del elemento en el arreglo o -1 si no se encuentra
+     */
+    private static <T> int busquedaBinaria(int init, int fin, T[] arreglo, T elemento, Comparator<T> comparador) {
+        int m = init + ((fin - init) / 2);
+        if (fin - init == 0)
+            return -1;
+        if (comparador.compare(elemento, arreglo[init]) == 0)
+            return init;
+        if (comparador.compare(elemento, arreglo[fin]) == 0)
+            return fin;
+        if (comparador.compare(elemento, arreglo[m]) == 0)
+            return m;
+        if (comparador.compare(elemento, arreglo[m]) > 0)
+            return busquedaBinaria(m + 1, fin, arreglo, elemento, comparador);
+        else
+            return busquedaBinaria(init, m, arreglo, elemento, comparador);
     }
 
     /**
@@ -74,8 +130,20 @@ public class Arreglos {
      * @param elemento el elemento a buscar.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T extends Comparable<T>> int
-    busquedaBinaria(T[] arreglo, T elemento) {
+    public static <T extends Comparable<T>> int busquedaBinaria(T[] arreglo, T elemento) {
         return busquedaBinaria(arreglo, elemento, (a, b) -> a.compareTo(b));
     }
+
+    /**
+     * Intercambia los elemento del primer indice con el segundo.
+     * 
+     * @param arreglo Arreglo de tipo generico
+     * @param a       Primer indice
+     * @param b       Segundo indice
+     */
+    private static <T> void intercambia(T[] arreglo, int a, int b) {
+        T aux = arreglo[a];
+        arreglo[a] = arreglo[b];
+        arreglo[b] = aux;
+    }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..b4904a5 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -10,7 +10,13 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String res = "";
+        Nodo aux = cabeza;
+        while (aux != null) {
+            res = res + aux.elemento + ",";
+            aux = aux.siguiente;
+        }
+        return res;
     }
 
     /**
@@ -20,6 +26,15 @@ public class Cola<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        if (rabo == null) {
+            cabeza = n;
+            rabo = n;
+        } else {
+            rabo.siguiente = n;
+            rabo = n;
+        }
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index b84a155..057b89a 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,7 +28,9 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            anterior = null;
+            siguiente = null;
         }
     }
 
@@ -41,37 +43,48 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
-            // Aquí va su código.
+            anterior = null;
+            siguiente = cabeza;
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return siguiente != null;
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
-            // Aquí va su código.
+            if (!hasNext())
+                throw new NoSuchElementException();
+            this.anterior = this.siguiente;
+            this.siguiente = this.siguiente.siguiente;
+            return this.anterior.elemento;
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return anterior != null;
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
-            // Aquí va su código.
+            if (!hasPrevious())
+                throw new NoSuchElementException();
+            this.siguiente = this.anterior;
+            this.anterior = this.anterior.anterior;
+            return this.siguiente.elemento;
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            anterior = null;
+            siguiente = cabeza;
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            siguiente = null;
+            anterior = rabo;
         }
     }
 
@@ -88,7 +101,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -97,7 +110,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -106,7 +119,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -118,7 +131,18 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) { // La cabeza y el rabo son el mismo nodo
+            this.cabeza = n;
+            this.rabo = n;
+        } else { // Agrega un nodo después del rabo y actualiza el rabo a ese nodo
+            n.anterior = this.rabo;
+            this.rabo.siguiente = n;
+            this.rabo = n;
+        }
     }
 
     /**
@@ -129,7 +153,19 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) {
+            this.cabeza = n;
+            this.rabo = n;
+        } else {
+            n.anterior = this.rabo;
+            this.rabo.siguiente = n;
+            this.rabo = n;
+        }
     }
 
     /**
@@ -140,7 +176,18 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) {
+            this.cabeza = n;
+            this.rabo = n;
+        } else { // Agrega un elemento antes de la cabeza y actualiza la cabeza
+            n.siguiente = this.cabeza;
+            this.cabeza.anterior = n;
+            this.cabeza = n;
+        }
     }
 
     /**
@@ -159,7 +206,41 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        } else if (i < 1) {
+            agregaInicio(elemento);
+        } else if (i > this.longitud - 1) {
+            agregaFinal(elemento);
+        } else {
+            if (0 < i && i <= longitud - 1) { // Se asegura otra vez que el indice esté
+                longitud++; // dentro del rango
+                Nodo s = iesimoNodo(i); // Nodo iesimo el cual va a ser el siguiente nodo del nuevo
+                Nodo n = new Nodo(elemento); // Nodo a agregar a la lista
+                Nodo a = s.anterior; // Nodo anterior al iesimo
+                n.anterior = a;
+                a.siguiente = n; // Agrega el nodo nuevo entre el s y el a
+                n.siguiente = s;
+                s.anterior = n;
+            }
+
+        }
+    }
+
+    /**
+     * Busca el nodo dado un indice
+     * 
+     * @param i Indice del nodo requerido
+     * @return El i-esimo nodo
+     */
+    public Nodo iesimoNodo(int i) {
+        Nodo aux = cabeza;
+        if (0 <= i && i <= longitud - 1) { // Se vuelve a asegurar que el indice se
+            for (int j = 0; j < i; j++) { // encuentre dentro del rango.
+                aux = aux.siguiente; // Recorre la lista hasta el iesimo nodo
+            }
+        }
+        return aux;
     }
 
     /**
@@ -168,7 +249,25 @@ public class Lista<T> implements Coleccion<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null || !contiene(elemento))
+            return;
+        if (cabeza.elemento.equals(elemento)) {
+            eliminaPrimero(); // Si el primer elemento es la cabeza elimina la cabeza
+            return;
+        }
+        if (contiene(elemento)) { // Si el elemento esta contenido en la lista:
+            Nodo aux = cabeza;
+            for (int i = 0; i < longitud - 2; i++) { // Recorre la lista hasta el penultimo elemento
+                if (aux.elemento.equals(elemento)) { // Encuentra el elemento recorrido con el
+                    aux.anterior.siguiente = aux.siguiente; // pasado como parametro
+                    aux.siguiente.anterior = aux.anterior; // elimina el nodo
+                    longitud--;
+                    return;
+                }
+                aux = aux.siguiente;
+            }
+            eliminaUltimo(); // Sino elimina el ultimo elemento
+        }
     }
 
     /**
@@ -177,7 +276,21 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
-        // Aquí va su código.
+        Nodo n = cabeza;
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        } else if (longitud == 1) { // La lista vacia
+            cabeza = null;
+            rabo = null;
+        } else if (longitud == 2) { // La lista con un elemento
+            cabeza = rabo;
+            rabo.anterior = null;
+        } else {
+            cabeza = cabeza.siguiente; // Elimina la cabeza y la actualiza.
+            cabeza.anterior = null;
+        }
+        this.longitud--;
+        return n.elemento;
     }
 
     /**
@@ -186,7 +299,21 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
-        // Aquí va su código.
+        Nodo n = rabo;
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        } else if (longitud == 1) { // La lista vacia
+            cabeza = null;
+            rabo = null;
+        } else if (longitud == 2) { // La lista con un elemento
+            rabo = cabeza;
+            cabeza.siguiente = null;
+        } else {
+            rabo = rabo.anterior; // Elimina el rabo y lo actualiza
+            rabo.siguiente = null;
+        }
+        this.longitud--;
+        return n.elemento;
     }
 
     /**
@@ -196,7 +323,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {// Recorre la lista en busca de un
+            if (aux.elemento.equals(elemento)) { // nodo con el mismo elemento
+                return true;
+            }
+            aux = aux.siguiente;
+        }
+        return false;
     }
 
     /**
@@ -204,7 +341,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> rev = new Lista<T>();
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) { // Añade los nuevos elementos
+            rev.agregaInicio(aux.elemento); // al principio
+            aux = aux.siguiente;
+        }
+        return rev;
     }
 
     /**
@@ -213,14 +356,22 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
-        // Aquí va su código.
+        Lista<T> copy = new Lista<T>();
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) { // Recorre la lista y conforme la recorre
+            copy.agrega(aux.elemento); // agrega los elementos a la nueva lista
+            aux = aux.siguiente;
+        }
+        return copy;
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        this.cabeza = null;
+        this.rabo = null;
+        this.longitud = 0;
     }
 
     /**
@@ -229,7 +380,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
-        // Aquí va su código.
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        }
+        return this.cabeza.elemento;
     }
 
     /**
@@ -238,7 +392,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
-        // Aquí va su código.
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        }
+        return this.rabo.elemento;
     }
 
     /**
@@ -249,7 +406,17 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if (i >= longitud || i < 0) {
+            throw new ExcepcionIndiceInvalido();
+        }
+        Nodo aux = cabeza; // Recorre la lista hasta que el indice buscado sea
+        for (int j = 0; j < longitud; j++) { // igual al nodo recorrido
+            if (j == i) {
+                break;
+            }
+            aux = aux.siguiente;
+        }
+        return aux.elemento;
     }
 
     /**
@@ -259,7 +426,17 @@ public class Lista<T> implements Coleccion<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo n = cabeza;
+        for (int i = 0; i < longitud; i++) { // Recorre la lista, la cantidad de veces necesaria
+            if (elemento.equals(n.elemento)) { // hasta encontrar el elemento y regresa el indice
+                return i;
+            }
+            n = n.siguiente;
+        }
+        return -1; // Si no lo encuentra regresa -1
     }
 
     /**
@@ -267,7 +444,20 @@ public class Lista<T> implements Coleccion<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if (longitud == 0) {
+            return "[]"; // La lista vacia
+        }
+        String res = "[";
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {
+            if (i == longitud - 1) {
+                res = res + aux.elemento + "]"; // Si es el ultimo elemento
+            } else {
+                res = res + aux.elemento + ", "; // Si es la cabeza o algun elemento
+                aux = aux.siguiente; // intermedio
+            }
+        }
+        return res;
     }
 
     /**
@@ -280,7 +470,15 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
+        if (lista.longitud != this.longitud) // Una lista es igual a otra si tiene la misma
+            return false; // longitud
+        Nodo aux = this.cabeza;
+        for (int i = 0; aux != null; i++) { // Recorre nodo con nodo y compara
+            if (!aux.elemento.equals(lista.get(i))) // elemento a elemento
+                return false;
+            aux = aux.siguiente;
+        }
+        return true;
     }
 
     /**
@@ -308,7 +506,56 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+        if (this.longitud == 1 || this.longitud == 0) {
+            return copia();
+        }
+        Lista<T> l1 = new Lista<>();
+        Lista<T> l2 = new Lista<>();
+
+        // Agregando elementos a la lista
+        for (int i = 0; i < this.longitud / 2; i++) {
+            l1.agrega(get(i));
+        }
+        for (int i = this.longitud / 2; i < this.longitud; i++) {
+            l2.agrega(get(i));
+        }
+
+        l1 = l1.mergeSort(comparador);
+        l2 = l2.mergeSort(comparador);
+        return mezcla(l1, l2, comparador);
+    }
+
+    /**
+     * Método auxiliar que mezcla 2 listas y las va ordenando en una nueva
+     * 
+     * @param lista1 Lista a ordenar
+     * @param lista2 Lista a ordenar
+     * @return La lista con los elementos ordenados de ambas listas
+     */
+    public Lista<T> mezcla(Lista<T> lista1, Lista<T> lista2, Comparator<T> comparador) {
+        Nodo i = lista1.cabeza;
+        Nodo j = lista2.cabeza;
+        Lista<T> lista = new Lista<T>();
+        while (i != null && j != null) {
+            if (comparador.compare(i.elemento, j.elemento) <= 0) {
+                lista.agrega(i.elemento);
+                i = i.siguiente;
+            } else {
+                lista.agrega(j.elemento);
+                j = j.siguiente;
+            }
+        }
+        if (i == null)
+            while (j != null) {
+                lista.agrega(j.elemento);
+                j = j.siguiente;
+            }
+        if (j == null)
+            while (i != null) {
+                lista.agrega(i.elemento);
+                i = i.siguiente;
+            }
+        return lista;
     }
 
     /**
@@ -333,7 +580,14 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {// Recorre la lista en busca de un
+            if ((comparador.compare(elemento, aux.elemento)) == 0) { // nodo con el mismo elemento
+                return true;
+            }
+            aux = aux.siguiente;
+        }
+        return false;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index c4206b0..5339206 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,7 +22,8 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            siguiente = null;
         }
     }
 
@@ -43,7 +44,14 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T saca() {
-        // Aquí va su código.
+        Nodo a = cabeza;
+        if (cabeza == null)
+            throw new NoSuchElementException();
+        cabeza = cabeza.siguiente;
+        if (cabeza == null) {
+            rabo = null;
+        }
+        return a.elemento;
     }
 
     /**
@@ -53,7 +61,11 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T mira() {
-        // Aquí va su código.
+        if (cabeza == null) {
+            throw new NoSuchElementException();
+        } else {
+            return cabeza.elemento;
+        }
     }
 
     /**
@@ -62,7 +74,7 @@ public abstract class MeteSaca<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -76,6 +88,30 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
+        Nodo auxClase = cabeza;
+        Nodo auxListaM = m.cabeza;
+        if (esVacia() && m.esVacia())
+            return true;
+        int i = 0;
+        while (auxClase != null) {
+            auxClase = auxClase.siguiente;
+            i++;
+        }
+        int j = 0;
+        while (auxListaM != null) {
+            auxListaM = auxListaM.siguiente;
+            j++;
+        }
+        if (i != j)
+            return false;
+        Nodo aux = cabeza;
+        Nodo auxM = m.cabeza;
+        while (aux != null) {
+            if (!aux.elemento.equals(auxM.elemento))
+                return false;
+            aux = aux.siguiente;
+            auxM = auxM.siguiente;
+        }
+        return true;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..87f5bba 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -10,7 +10,13 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String res = "";
+        Nodo aux = cabeza;
+        while (aux != null) {
+            res = res + aux.elemento + "\n";
+            aux = aux.siguiente;
+        }
+        return res;
     }
 
     /**
@@ -20,6 +26,15 @@ public class Pila<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        if (cabeza == null) {
+            cabeza = n;
+            rabo = n;
+        } else {
+            n.siguiente = cabeza;
+            cabeza = n;
+        }
     }
 }
