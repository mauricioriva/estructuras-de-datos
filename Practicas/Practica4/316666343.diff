diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index aec1cf8..dbda238 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -1,12 +1,17 @@
 package mx.unam.ciencias.edd;
 
+import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 /**
- * <p>Clase abstracta para árboles binarios genéricos.</p>
+ * <p>
+ * Clase abstracta para árboles binarios genéricos.
+ * </p>
  *
- * <p>La clase proporciona las operaciones básicas para árboles binarios, pero
- * deja la implementación de varias en manos de las subclases concretas.</p>
+ * <p>
+ * La clase proporciona las operaciones básicas para árboles binarios, pero deja
+ * la implementación de varias en manos de las subclases concretas.
+ * </p>
  */
 public abstract class ArbolBinario<T> implements Coleccion<T> {
 
@@ -26,113 +31,175 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
 
         /**
          * Constructor único que recibe un elemento.
+         * 
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            padre = null;
+            izquierdo = null;
+            derecho = null;
         }
 
         /**
          * Nos dice si el vértice tiene un padre.
-         * @return <tt>true</tt> si el vértice tiene padre,
-         *         <tt>false</tt> en otro caso.
+         * 
+         * @return <tt>true</tt> si el vértice tiene padre, <tt>false</tt> en otro caso.
          */
-        @Override public boolean hayPadre() {
-            // Aquí va su código.
+        @Override
+        public boolean hayPadre() {
+            return padre != null;
         }
 
         /**
          * Nos dice si el vértice tiene un izquierdo.
-         * @return <tt>true</tt> si el vértice tiene izquierdo,
-         *         <tt>false</tt> en otro caso.
+         * 
+         * @return <tt>true</tt> si el vértice tiene izquierdo, <tt>false</tt> en otro
+         *         caso.
          */
-        @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+        @Override
+        public boolean hayIzquierdo() {
+            return izquierdo != null;
         }
 
         /**
          * Nos dice si el vértice tiene un derecho.
-         * @return <tt>true</tt> si el vértice tiene derecho,
-         *         <tt>false</tt> en otro caso.
+         * 
+         * @return <tt>true</tt> si el vértice tiene derecho, <tt>false</tt> en otro
+         *         caso.
          */
-        @Override public boolean hayDerecho() {
-            // Aquí va su código.
+        @Override
+        public boolean hayDerecho() {
+            return derecho != null;
         }
 
         /**
          * Regresa el padre del vértice.
+         * 
          * @return el padre del vértice.
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
-        @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+        @Override
+        public VerticeArbolBinario<T> padre() {
+            if (padre == null)
+                throw new NoSuchElementException();
+            return padre;
         }
 
         /**
          * Regresa el izquierdo del vértice.
+         * 
          * @return el izquierdo del vértice.
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
-        @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+        @Override
+        public VerticeArbolBinario<T> izquierdo() {
+            if (izquierdo == null)
+                throw new NoSuchElementException();
+            return izquierdo;
         }
 
         /**
          * Regresa el derecho del vértice.
+         * 
          * @return el derecho del vértice.
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
-        @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+        @Override
+        public VerticeArbolBinario<T> derecho() {
+            if (derecho == null)
+                throw new NoSuchElementException();
+            return derecho;
         }
 
         /**
          * Regresa la altura del vértice.
+         * 
          * @return la altura del vértice.
          */
-        @Override public int altura() {
-            // Aquí va su código.
+        @Override
+        public int altura() {
+            if (hayIzquierdo() && hayDerecho()) {
+                return 1 + Math.max(izquierdo.altura(), derecho.altura());
+            } else if (hayIzquierdo()) {
+                return 1 + izquierdo.altura();
+            } else if (hayDerecho()) {
+                return 1 + derecho.altura();
+            } else {
+                return 0;
+            }
         }
 
         /**
          * Regresa la profundidad del vértice.
+         * 
          * @return la profundidad del vértice.
          */
-        @Override public int profundidad() {
-            // Aquí va su código.
+        @Override
+        public int profundidad() {
+            if (padre == null)
+                return 0;
+            return 1 + padre.profundidad();
         }
 
         /**
          * Regresa el elemento al que apunta el vértice.
+         * 
          * @return el elemento al que apunta el vértice.
          */
-        @Override public T get() {
-            // Aquí va su código.
+        @Override
+        public T get() {
+            return elemento;
         }
 
         /**
-         * Compara el vértice con otro objeto. La comparación es
-         * <em>recursiva</em>. Las clases que extiendan {@link Vertice} deben
-         * sobrecargar el método {@link Vertice#equals}.
+         * Compara el vértice con otro objeto. La comparación es <em>recursiva</em>. Las
+         * clases que extiendan {@link Vertice} deben sobrecargar el método
+         * {@link Vertice#equals}.
+         * 
          * @param objeto el objeto con el cual se comparará el vértice.
          * @return <code>true</code> si el objeto es instancia de la clase
-         *         {@link Vertice}, su elemento es igual al elemento de éste
-         *         vértice, y los descendientes de ambos son recursivamente
-         *         iguales; <code>false</code> en otro caso.
+         *         {@link Vertice}, su elemento es igual al elemento de éste vértice, y
+         *         los descendientes de ambos son recursivamente iguales;
+         *         <code>false</code> en otro caso.
          */
-        @Override public boolean equals(Object objeto) {
+        @Override
+        public boolean equals(Object objeto) {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
-            @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
+            @SuppressWarnings("unchecked")
+            Vertice vertice = (Vertice) objeto;
+            return auxEquals(this, vertice);
+        }
+
+        /**
+         * Método auxiliar recursivo el cual recibe 2 vertices y revisa si sus
+         * subsecuentes son iguales.
+         * 
+         * @param a vertice a comparar
+         * @param b vertice a comparar
+         */
+        private boolean auxEquals(Vertice a, Vertice b) {
+            if (a == null && b == null)
+                return true;
+            if (a != null && b != null) {
+                if (!a.elemento.equals(b.elemento))
+                    return false;
+                if (auxEquals(a.izquierdo, b.izquierdo))
+                    return auxEquals(a.derecho, b.derecho);
+                return false;
+            }
+            return false;
         }
 
         /**
          * Regresa una representación en cadena del vértice.
+         * 
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+            String s = "";
+            return s + elemento.toString();
         }
     }
 
@@ -144,24 +211,28 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
     /**
      * Constructor sin parámetros. Tenemos que definirlo para no perderlo.
      */
-    public ArbolBinario() {}
+    public ArbolBinario() {
+    }
 
     /**
-     * Construye un árbol binario a partir de una colección. El árbol binario
-     * tendrá los mismos elementos que la colección recibida.
-     * @param coleccion la colección a partir de la cual creamos el árbol
-     *        binario.
+     * Construye un árbol binario a partir de una colección. El árbol binario tendrá
+     * los mismos elementos que la colección recibida.
+     * 
+     * @param coleccion la colección a partir de la cual creamos el árbol binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        coleccion.forEach((t) -> {
+            agrega(t);
+        });
     }
 
     /**
      * Construye un nuevo vértice, usando una instancia de {@link Vertice}. Para
      * crear vértices se debe utilizar este método en lugar del operador
-     * <code>new</code>, para que las clases herederas de ésta puedan
-     * sobrecargarlo y permitir que cada estructura de árbol binario utilice
-     * distintos tipos de vértices.
+     * <code>new</code>, para que las clases herederas de ésta puedan sobrecargarlo
+     * y permitir que cada estructura de árbol binario utilice distintos tipos de
+     * vértices.
+     * 
      * @param elemento el elemento dentro del vértice.
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
@@ -170,100 +241,209 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
     }
 
     /**
-     * Regresa la altura del árbol. La altura de un árbol es la altura de su
-     * raíz.
+     * Regresa la altura del árbol. La altura de un árbol es la altura de su raíz.
+     * 
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        if (elementos == 0)
+            return -1;
+        else
+            return raiz.altura();
     }
 
     /**
      * Regresa el número de elementos que se han agregado al árbol.
+     * 
      * @return el número de elementos en el árbol.
      */
-    @Override public int getElementos() {
-        // Aquí va su código.
+    @Override
+    public int getElementos() {
+        return elementos;
     }
 
     /**
      * Nos dice si un elemento está en el árbol binario.
+     * 
      * @param elemento el elemento que queremos comprobar si está en el árbol.
-     * @return <code>true</code> si el elemento está en el árbol;
-     *         <code>false</code> en otro caso.
+     * @return <code>true</code> si el elemento está en el árbol; <code>false</code>
+     *         en otro caso.
      */
-    @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+    @Override
+    public boolean contiene(T elemento) {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        if (busca(elemento) == null)
+            return false;
+        else
+            return true;
     }
 
     /**
      * Busca el vértice de un elemento en el árbol. Si no lo encuentra regresa
      * <tt>null</tt>.
+     * 
      * @param elemento el elemento para buscar el vértice.
      * @return un vértice que contiene el elemento buscado si lo encuentra;
      *         <tt>null</tt> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        if (esVacia())
+            return null;
+        return buscaAux(raiz(), elemento);
+    }
+
+    /**
+     * Método auxiliar que busca un elemento en todos los nodos de la izquierda y de
+     * la derecha recursivamente.
+     * 
+     * @param v        vertice a comparar con el elemento.
+     * @param elemento elemento a comparar con los vertices del árbol.
+     */
+    private VerticeArbolBinario<T> buscaAux(VerticeArbolBinario<T> v, T elemento) {
+        if (v.get().equals(elemento))
+            return v;
+        if (v.hayIzquierdo())
+            if ((buscaAux(v.izquierdo(), elemento)) != null)
+                return (buscaAux(v.izquierdo(), elemento));
+        if (v.hayDerecho())
+            if ((buscaAux(v.derecho(), elemento)) != null)
+                return (buscaAux(v.derecho(), elemento));
+        return null;
     }
 
     /**
      * Regresa el vértice que contiene la raíz del árbol.
+     * 
      * @return el vértice que contiene la raíz del árbol.
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+        if (esVacia())
+            throw new NoSuchElementException();
+        return raiz;
     }
 
     /**
      * Nos dice si el árbol es vacío.
-     * @return <code>true</code> si el árbol es vacío, <code>false</code> en
-     *         otro caso.
+     * 
+     * @return <code>true</code> si el árbol es vacío, <code>false</code> en otro
+     *         caso.
      */
-    @Override public boolean esVacia() {
-        // Aquí va su código.
+    @Override
+    public boolean esVacia() {
+        return raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
-    @Override public void limpia() {
-        // Aquí va su código.
+    @Override
+    public void limpia() {
+        raiz = null;
+        elementos = 0;
     }
 
     /**
      * Compara el árbol con un objeto.
+     * 
      * @param objeto el objeto con el que queremos comparar el árbol.
      * @return <code>true</code> si el objeto recibido es un árbol binario y los
      *         árboles son iguales; <code>false</code> en otro caso.
      */
-    @Override public boolean equals(Object objeto) {
+    @Override
+    public boolean equals(Object objeto) {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked")
-            ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+        ArbolBinario<T> arbol = (ArbolBinario<T>) objeto;
+        if (esVacia() && arbol.esVacia())
+            return true;
+        else
+            return raiz.equals(arbol.raiz);
     }
 
     /**
      * Regresa una representación en cadena del árbol.
+     * 
      * @return una representación en cadena del árbol.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override
+    public String toString() {
+        if (raiz == null)
+            return "";
+        int a[] = new int[altura() + 1];
+        for (int i = 0; i < altura() + 1; i++) {
+            a[i] = 0;
+        }
+        return cadena(raiz, 0, a);
+    }
+
+    /**
+     * Método auxiliar que maneja los niveles del árbol para ilustrar en la cadena,
+     * el significado de los simbolos es: con una '>' es el izquierdo, con dos '>>'
+     * es el derecho.
+     * 
+     * @param v     vertice el cual se imprime su elemento.
+     * @param nivel el nivel del arbol el cual imprime los elementos.
+     * @param a     arreglo de 0 y 1.
+     */
+    private String cadena(Vertice v, int nivel, int[] a) {
+        String s = v.toString() + "\n";
+        a[nivel] = 1;
+        if (v.hayIzquierdo() && v.hayDerecho()) {
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "├─›";
+            s = s + cadena(v.izquierdo, nivel + 1, a);
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─»";
+            a[nivel] = 0;
+            s = s + cadena(v.derecho, nivel + 1, a);
+        } else if (v.hayIzquierdo()) {
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─›";
+            a[nivel] = 0;
+            s = s + cadena(v.izquierdo, nivel + 1, a);
+        } else if (v.hayDerecho()) {
+            s = s + dibujaEspacios(nivel, a);
+            s = s + "└─»";
+            a[nivel] = 0;
+            s = s + cadena(v.derecho, nivel + 1, a);
+        }
+        return s;
+    }
+
+    /**
+     * Método auxiliar que dibuja los espacios correspondientes para la
+     * representación en cadena del árbol.
+     * 
+     * @param nivel el nivel del arbol el cual imprime los elementos.
+     * @param a     arreglo de 0 y 1.
+     */
+    private String dibujaEspacios(int nivel, int[] a) {
+        String s = "";
+        for (int i = 0; i <= nivel - 1; i++) {
+            if (a[i] == 1) {
+                s = s + "│  ";
+            } else {
+                s = s + "   ";
+            }
+        }
+        return s;
     }
 
     /**
-     * Convierte el vértice (visto como instancia de {@link
-     * VerticeArbolBinario}) en vértice (visto como instancia de {@link
-     * Vertice}). Método auxiliar para hacer esta audición en un único lugar.
+     * Convierte el vértice (visto como instancia de {@link VerticeArbolBinario}) en
+     * vértice (visto como instancia de {@link Vertice}). Método auxiliar para hacer
+     * esta audición en un único lugar.
+     * 
      * @param vertice el vértice de árbol binario que queremos como vértice.
      * @return el vértice recibido visto como vértice.
-     * @throws ClassCastException si el vértice no es instancia de {@link
-     *         Vertice}.
+     * @throws ClassCastException si el vértice no es instancia de {@link Vertice}.
      */
     protected Vertice vertice(VerticeArbolBinario<T> vertice) {
-        return (Vertice)vertice;
+        return (Vertice) vertice;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 97a2ea0..9079fdd 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -1,6 +1,7 @@
 package mx.unam.ciencias.edd;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * <p>Clase para árboles binarios completos.</p>
@@ -16,19 +17,26 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
         /* Cola para recorrer los vértices en BFS. */
         private Cola<Vertice> cola;
 
-        /* Inicializa al iterador. */
+        /* Constructor que recibe la raíz del árbol. */
         public Iterador() {
-            // Aquí va su código.
+            cola = new Cola<Vertice>();
+            if (raiz != null){
+                cola.mete(raiz);
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+            if (cola.esVacia()) throw new NoSuchElementException();
+            Vertice v = cola.saca();
+            if (v.hayIzquierdo()) cola.mete(v.izquierdo);
+            if (v.hayDerecho()) cola.mete(v.derecho);
+            return v.get();
         }
     }
 
@@ -56,7 +64,32 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        Vertice nuevo = nuevoVertice(elemento);        
+        elementos++;
+        if (esVacia()) raiz = nuevo;
+        else {
+            Cola<VerticeArbolBinario<T>> cola = new Cola<>();
+            cola.mete(raiz());
+            VerticeArbolBinario<T> v;
+            while (!cola.esVacia()) {
+                v = cola.saca();
+                if (v.hayIzquierdo()) cola.mete(v.izquierdo());
+                if (v.hayDerecho()) cola.mete(v.derecho());
+                if (!v.hayIzquierdo()) {
+                    Vertice a = vertice(v);
+                    a.izquierdo = nuevo;
+                    nuevo.padre = a;
+                    return;
+                }
+                if (!v.hayDerecho()) {
+                    Vertice b = vertice(v);
+                    b.derecho = nuevo;
+                    nuevo.padre = b;
+                    return;
+                }
+            }      
+        }
     }
 
     /**
@@ -66,7 +99,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) throw new IllegalArgumentException();
+        if (!contiene(elemento)) return;
+        elementos--;
+        if (elementos == 0) {
+            limpia();
+            return;
+        }
+        Cola<Vertice> cola = new Cola<>();
+        cola.mete(raiz);
+        Vertice ultimo = null;
+        while (!cola.esVacia()) {
+            ultimo = cola.saca();
+            if (ultimo.hayIzquierdo()) cola.mete(ultimo.izquierdo);
+            if (ultimo.hayDerecho()) cola.mete(ultimo.derecho);
+        }
+        Vertice e = vertice(busca(elemento));
+        e.elemento = ultimo.elemento;
+        Vertice padre = ultimo.padre;
+        if (padre.izquierdo == ultimo) {
+            padre.izquierdo = null;
+        } else {
+            padre.derecho = null;
+        }
     }
 
     /**
@@ -75,7 +130,8 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
-        // Aquí va su código.
+        if (raiz == null) return -1;
+        return (int)(Math.floor(Math.log(elementos) / Math.log(2)));
     }
 
     /**
@@ -84,7 +140,15 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (esVacia()) return;
+        Cola<VerticeArbolBinario<T>> cola = new Cola<>();
+        cola.mete(raiz());
+        while (!cola.esVacia()) {
+            VerticeArbolBinario<T> v = cola.saca();
+            accion.actua(v);
+            if (v.hayIzquierdo()) cola.mete(v.izquierdo());
+            if (v.hayDerecho()) cola.mete(v.derecho());
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index 127acf9..b487312 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -1,21 +1,25 @@
 package mx.unam.ciencias.edd;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
- * <p>Clase para árboles binarios ordenados. Los árboles son genéricos, pero
- * acotados a la interfaz {@link Comparable}.</p>
+ * <p>
+ * Clase para árboles binarios ordenados. Los árboles son genéricos, pero
+ * acotados a la interfaz {@link Comparable}.
+ * </p>
  *
- * <p>Un árbol instancia de esta clase siempre cumple que:</p>
+ * <p>
+ * Un árbol instancia de esta clase siempre cumple que:
+ * </p>
  * <ul>
- *   <li>Cualquier elemento en el árbol es mayor o igual que todos sus
- *       descendientes por la izquierda.</li>
- *   <li>Cualquier elemento en el árbol es menor o igual que todos sus
- *       descendientes por la derecha.</li>
+ * <li>Cualquier elemento en el árbol es mayor o igual que todos sus
+ * descendientes por la izquierda.</li>
+ * <li>Cualquier elemento en el árbol es menor o igual que todos sus
+ * descendientes por la derecha.</li>
  * </ul>
  */
-public class ArbolBinarioOrdenado<T extends Comparable<T>>
-    extends ArbolBinario<T> {
+public class ArbolBinarioOrdenado<T extends Comparable<T>> extends ArbolBinario<T> {
 
     /* Clase interna privada para iteradores. */
     private class Iterador implements Iterator<T> {
@@ -23,42 +27,62 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
         /* Pila para recorrer los vértices en DFS in-order. */
         private Pila<Vertice> pila;
 
-        /* Inicializa al iterador. */
+        /* Construye un iterador con el vértice recibido. */
         public Iterador() {
-            // Aquí va su código.
+            pila = new Pila<Vertice>();
+            if (raiz != null) {
+                pila.mete(raiz);
+                Vertice aux = raiz;
+                while (aux.hayIzquierdo()) {
+                    pila.mete(aux.izquierdo);
+                    aux = aux.izquierdo;
+                }
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
-        @Override public boolean hasNext() {
-            // Aquí va su código.
+        @Override
+        public boolean hasNext() {
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
-        @Override public T next() {
-            // Aquí va su código.
+        @Override
+        public T next() {
+            Vertice aux = pila.saca();
+            T t = aux.get();
+            aux = aux.derecho;
+            while (aux != null) {
+                pila.mete(aux);
+                aux = aux.izquierdo;
+            }
+            return t;
         }
     }
 
     /**
-     * El vértice del último elemento agegado. Este vértice sólo se puede
-     * garantizar que existe <em>inmediatamente</em> después de haber agregado
-     * un elemento al árbol. Si cualquier operación distinta a agregar sobre el
-     * árbol se ejecuta después de haber agregado un elemento, el estado de esta
-     * variable es indefinido.
+     * El vértice del último elemento agegado. Este vértice sólo se puede garantizar
+     * que existe <em>inmediatamente</em> después de haber agregado un elemento al
+     * árbol. Si cualquier operación distinta a agregar sobre el árbol se ejecuta
+     * después de haber agregado un elemento, el estado de esta variable es
+     * indefinido.
      */
     protected Vertice ultimoAgregado;
 
     /**
-     * Constructor sin parámetros. Para no perder el constructor sin parámetros
-     * de {@link ArbolBinario}.
+     * Constructor sin parámetros. Para no perder el constructor sin parámetros de
+     * {@link ArbolBinario}.
      */
-    public ArbolBinarioOrdenado() { super(); }
+    public ArbolBinarioOrdenado() {
+        super();
+    }
 
     /**
      * Construye un árbol binario ordenado a partir de una colección. El árbol
      * binario ordenado tiene los mismos elementos que la colección recibida.
-     * @param coleccion la colección a partir de la cual creamos el árbol
-     *        binario ordenado.
+     * 
+     * @param coleccion la colección a partir de la cual creamos el árbol binario
+     *                  ordenado.
      */
     public ArbolBinarioOrdenado(Coleccion<T> coleccion) {
         super(coleccion);
@@ -66,121 +90,338 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
     /**
      * Agrega un nuevo elemento al árbol. El árbol conserva su orden in-order.
+     * 
      * @param elemento el elemento a agregar.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override
+    public void agrega(T elemento) {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Vertice nuevo = nuevoVertice(elemento);
+        elementos++;
+        if (raiz == null) {
+            raiz = nuevo;
+            ultimoAgregado = nuevo;
+            return;
+        } else {
+            auxAgrega(raiz, nuevo);
+            ultimoAgregado = nuevo;
+        }
+    }
+
+    /**
+     * Método auxiliar para recorrer el árbol de acuerdo a si el elemento es mayor,
+     * menor o igual y hasta encontrar una hoja colocarse allí, al final del árbol.
+     * 
+     * @param actual Vertice con el cual se va a comparar, si es mayor, menor o
+     *               igual.
+     * @param nuevo  Vertice el cual se va a agregar al árbol.
+     */
+    private void auxAgrega(Vertice actual, Vertice nuevo) {
+        if ((nuevo.get().compareTo(actual.get())) <= 0) {
+            if (!actual.hayIzquierdo()) {
+                actual.izquierdo = nuevo;
+                nuevo.padre = actual;
+                return;
+            } else
+                auxAgrega(actual.izquierdo, nuevo);
+        } else {
+            if (!actual.hayDerecho()) {
+                actual.derecho = nuevo;
+                nuevo.padre = actual;
+                return;
+            } else
+                auxAgrega(actual.derecho, nuevo);
+        }
     }
 
     /**
      * Elimina un elemento. Si el elemento no está en el árbol, no hace nada; si
      * está varias veces, elimina el primero que encuentre (in-order). El árbol
      * conserva su orden in-order.
+     * 
      * @param elemento el elemento a eliminar.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override
+    public void elimina(T elemento) {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        if (busca(elemento) == null)
+            return;
+        VerticeArbolBinario<T> e = busca(elemento);
+        Vertice aEliminar = vertice(e);
+        elementos--;
+        if (elementos == 0)
+            limpia();
+        if (aEliminar.hayIzquierdo() && aEliminar.hayDerecho()) {
+            aEliminar = intercambiaEliminable(aEliminar);
+        }
+        eliminaVertice(aEliminar);
     }
 
     /**
      * Intercambia el elemento de un vértice con dos hijos distintos de
-     * <code>null</code> con el elemento de un descendiente que tenga a lo más
-     * un hijo.
+     * <code>null</code> con el elemento de un descendiente que tenga a lo más un
+     * hijo.
+     * 
      * @param vertice un vértice con dos hijos distintos de <code>null</code>.
-     * @return el vértice descendiente con el que vértice recibido se
-     *         intercambió. El vértice regresado tiene a lo más un hijo distinto
-     *         de <code>null</code>.
+     * @return el vértice descendiente con el que vértice recibido se intercambió.
+     *         El vértice regresado tiene a lo más un hijo distinto de
+     *         <code>null</code>.
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        Vertice v = maximoEnSubArbol(vertice.izquierdo);
+        T t = v.get();
+        v.elemento = vertice.elemento;
+        vertice.elemento = t;
+        return v;
     }
 
     /**
-     * Elimina un vértice que a lo más tiene un hijo distinto de
-     * <code>null</code> subiendo ese hijo (si existe).
-     * @param vertice el vértice a eliminar; debe tener a lo más un hijo
-     *                distinto de <code>null</code>.
+     * Elimina un vértice que a lo más tiene un hijo distinto de <code>null</code>
+     * subiendo ese hijo (si existe).
+     * 
+     * @param vertice el vértice a eliminar; debe tener a lo más un hijo distinto de
+     *                <code>null</code>.
      */
     protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+        Vertice hijo = null;
+        Vertice padre = null;
+        if (vertice.hayIzquierdo())
+            hijo = vertice.izquierdo;
+        if (vertice.hayDerecho())
+            hijo = vertice.derecho;
+        if (vertice.hayPadre())
+            padre = vertice.padre;
+
+        if (padre != null) {
+            if (padre.izquierdo == vertice) { // Aqui estaba la falla :v
+                padre.izquierdo = hijo;
+            } else {
+                padre.derecho = hijo;
+            }
+        } else if (padre == null)
+            raiz = hijo;
+
+        if (hijo != null)
+            hijo.padre = padre;
+
+    }
+
+    /**
+     * Te regresa el elemento máximo de un subarbol
+     * 
+     * @param v vertice el cual es la raiz de un subarbol
+     */
+    private Vertice maximoEnSubArbol(Vertice v) {
+        if (!v.hayDerecho())
+            return v;
+        return maximoEnSubArbol(v.derecho);
     }
 
     /**
      * Busca un elemento en el árbol recorriéndolo in-order. Si lo encuentra,
      * regresa el vértice que lo contiene; si no, regresa <tt>null</tt>.
+     * 
      * @param elemento el elemento a buscar.
-     * @return un vértice que contiene al elemento buscado si lo
-     *         encuentra; <tt>null</tt> en otro caso.
+     * @return un vértice que contiene al elemento buscado si lo encuentra;
+     *         <tt>null</tt> en otro caso.
      */
-    @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+    @Override
+    public VerticeArbolBinario<T> busca(T elemento) {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        if (esVacia())
+            return null;
+        return buscaAux(raiz(), elemento);
     }
 
     /**
-     * Regresa el vértice que contiene el último elemento agregado al
-     * árbol. Este método sólo se puede garantizar que funcione
-     * <em>inmediatamente</em> después de haber invocado al método {@link
-     * agrega}. Si cualquier operación distinta a agregar sobre el árbol se
-     * ejecuta después de haber agregado un elemento, el comportamiento de este
-     * método es indefinido.
-     * @return el vértice que contiene el último elemento agregado al árbol, si
-     *         el método es invocado inmediatamente después de agregar un
-     *         elemento al árbol.
+     * Método auxiliar que busca recursivamente el elemento, debido a que el árbol
+     * está ordenado si el elemento es mayor busca por la derecha, si es menor o
+     * igual busca por la izquierda, si llega a alguna hoja implica que no encontró
+     * el elemento y regresa <tt>null</tt>.
+     * 
+     * @param el elemento a buscar.
+     * @return vertice encontrado que contiene el elemento, <tt>null</tt> en otro
+     *         caso.
+     */
+    private VerticeArbolBinario<T> buscaAux(VerticeArbolBinario<T> v, T elemento) {
+        if (elemento.compareTo(v.get()) == 0)
+            return v;
+        else if (elemento.compareTo(v.get()) <= 0)
+            if (v.hayIzquierdo())
+                return buscaAux(v.izquierdo(), elemento);
+            else
+                return null;
+        else if (elemento.compareTo(v.get()) > 0)
+            if (v.hayDerecho())
+                return buscaAux(v.derecho(), elemento);
+            else
+                return null;
+        return null;
+    }
+
+    /**
+     * Regresa el vértice que contiene el último elemento agregado al árbol. Este
+     * método sólo se puede garantizar que funcione <em>inmediatamente</em> después
+     * de haber invocado al método {@link agrega}. Si cualquier operación distinta a
+     * agregar sobre el árbol se ejecuta después de haber agregado un elemento, el
+     * comportamiento de este método es indefinido.
+     * 
+     * @return el vértice que contiene el último elemento agregado al árbol, si el
+     *         método es invocado inmediatamente después de agregar un elemento al
+     *         árbol.
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
         return ultimoAgregado;
     }
 
     /**
-     * Gira el árbol a la derecha sobre el vértice recibido. Si el vértice no
-     * tiene hijo izquierdo, el método no hace nada.
+     * Gira el árbol a la derecha sobre el vértice recibido. Si el vértice no tiene
+     * hijo izquierdo, el método no hace nada.
+     * 
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (!vertice.hayIzquierdo() || vertice == null)
+            return;
+        Vertice q = vertice(vertice);
+        Vertice p = q.izquierdo;
+        Vertice s = p.derecho;
+        p.derecho = q;
+        p.padre = q.padre;
+        q.izquierdo = s;
+        if (q.hayIzquierdo())
+            s.padre = q; // Verificamos si 's' existe
+        if (!p.hayPadre()) { // Preguntamos si 'q' es la raiz
+            raiz = p;
+            q.padre = p;
+            return;
+        }
+        if (q == q.padre.derecho)
+            q.padre.derecho = p; // Ajustamos si el vertice es izq o derecho
+        else
+            q.padre.izquierdo = p; // del padre
+        q.padre = p;
     }
 
     /**
      * Gira el árbol a la izquierda sobre el vértice recibido. Si el vértice no
      * tiene hijo derecho, el método no hace nada.
+     * 
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (!vertice.hayDerecho())
+            return;
+        Vertice p = vertice(vertice);
+        Vertice q = p.derecho;
+        Vertice s = q.izquierdo;
+        q.izquierdo = p;
+        q.padre = p.padre;
+        p.derecho = s;
+        if (p.hayDerecho())
+            s.padre = p; // Verificamos si 's' existe
+        if (!q.hayPadre()) { // Preguntamos si 'p' es la raiz
+            raiz = q;
+            p.padre = q;
+            return;
+        }
+        if (p == p.padre.izquierdo)
+            p.padre.izquierdo = q; // Ajustamos si el vertice es izquierdo o derecho
+        else
+            p.padre.derecho = q; // del padre
+        p.padre = q;
     }
 
     /**
-     * Realiza un recorrido DFS <em>pre-order</em> en el árbol, ejecutando la
-     * acción recibida en cada elemento del árbol.
+     * Realiza un recorrido DFS <em>pre-order</em> en el árbol, ejecutando la acción
+     * recibida en cada elemento del árbol.
+     * 
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        auxDfsPreOrder(raiz(), accion);
     }
 
     /**
-     * Realiza un recorrido DFS <em>in-order</em> en el árbol, ejecutando la
-     * acción recibida en cada elemento del árbol.
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS
+     * <em>pre-order</em>
+     * 
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices
+     *               del árbol.
+     * @param v      Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsPreOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion) {
+        accion.actua(v);
+        if (v.hayIzquierdo())
+            auxDfsPreOrder(v.izquierdo(), accion);
+        if (v.hayDerecho())
+            auxDfsPreOrder(v.derecho(), accion);
+    }
+
+    /**
+     * Realiza un recorrido DFS <em>in-order</em> en el árbol, ejecutando la acción
+     * recibida en cada elemento del árbol.
+     * 
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (esVacia())
+            return;
+        auxDfsInOrder(raiz(), accion);
+    }
+
+    /**
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS
+     * <em>in-order</em>
+     * 
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices
+     *               del árbol.
+     * @param v      Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsInOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion) {
+        if (v.hayIzquierdo())
+            auxDfsInOrder(v.izquierdo(), accion);
+        accion.actua(v);
+        if (v.hayDerecho())
+            auxDfsInOrder(v.derecho(), accion);
     }
 
     /**
      * Realiza un recorrido DFS <em>post-order</em> en el árbol, ejecutando la
      * acción recibida en cada elemento del árbol.
+     * 
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        auxDfsPostOrder(raiz(), accion);
+    }
+
+    /**
+     * Recursivamente aplica una accion siguiendo el recorrido de DFS
+     * <em>post-order</em>
+     * 
+     * @param accion Recibe una lambda la cual puede interactuar con los vertices
+     *               del árbol.
+     * @param v      Vertice al cual se le aplica la acción.
+     */
+    private void auxDfsPostOrder(VerticeArbolBinario<T> v, AccionVerticeArbolBinario<T> accion) {
+        if (v.hayIzquierdo())
+            auxDfsPostOrder(v.izquierdo(), accion);
+        if (v.hayDerecho())
+            auxDfsPostOrder(v.derecho(), accion);
+        accion.actua(v);
     }
 
     /**
      * Regresa un iterador para iterar el árbol. El árbol se itera en orden.
+     * 
      * @return un iterador para iterar el árbol.
      */
-    @Override public Iterator<T> iterator() {
+    @Override
+    public Iterator<T> iterator() {
         return new Iterador();
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
index 909b16b..b135135 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
@@ -5,18 +5,17 @@ package mx.unam.ciencias.edd;
  * propiedades:
  *
  * <ol>
- *  <li>Todos los vértices son NEGROS o ROJOS.</li>
- *  <li>La raíz es NEGRA.</li>
- *  <li>Todas las hojas (<tt>null</tt>) son NEGRAS (al igual que la raíz).</li>
- *  <li>Un vértice ROJO siempre tiene dos hijos NEGROS.</li>
- *  <li>Todo camino de un vértice a alguna de sus hojas descendientes tiene el
- *      mismo número de vértices NEGROS.</li>
+ * <li>Todos los vértices son NEGROS o ROJOS.</li>
+ * <li>La raíz es NEGRA.</li>
+ * <li>Todas las hojas (<tt>null</tt>) son NEGRAS (al igual que la raíz).</li>
+ * <li>Un vértice ROJO siempre tiene dos hijos NEGROS.</li>
+ * <li>Todo camino de un vértice a alguna de sus hojas descendientes tiene el
+ * mismo número de vértices NEGROS.</li>
  * </ol>
  *
  * Los árboles rojinegros se autobalancean.
  */
-public class ArbolRojinegro<T extends Comparable<T>>
-    extends ArbolBinarioOrdenado<T> {
+public class ArbolRojinegro<T extends Comparable<T>> extends ArbolBinarioOrdenado<T> {
 
     /**
      * Clase interna protegida para vértices.
@@ -28,119 +27,402 @@ public class ArbolRojinegro<T extends Comparable<T>>
 
         /**
          * Constructor único que recibe un elemento.
+         * 
          * @param elemento el elemento del vértice.
          */
         public VerticeRojinegro(T elemento) {
-            // Aquí va su código.
+            super(elemento);
+            this.color = Color.NINGUNO;
         }
 
         /**
          * Regresa una representación en cadena del vértice rojinegro.
+         * 
          * @return una representación en cadena del vértice rojinegro.
          */
         public String toString() {
-            // Aquí va su código.
+            if (this.color == Color.ROJO) {
+                return "R{" + elemento.toString() + "}";
+            } else {
+                return "N{" + elemento.toString() + "}";
+            }
         }
 
         /**
-         * Compara el vértice con otro objeto. La comparación es
-         * <em>recursiva</em>.
+         * Compara el vértice con otro objeto. La comparación es <em>recursiva</em>.
+         * 
          * @param objeto el objeto con el cual se comparará el vértice.
          * @return <code>true</code> si el objeto es instancia de la clase
-         *         {@link VerticeRojinegro}, su elemento es igual al elemento de
-         *         éste vértice, los descendientes de ambos son recursivamente
-         *         iguales, y los colores son iguales; <code>false</code> en
-         *         otro caso.
+         *         {@link VerticeRojinegro}, su elemento es igual al elemento de éste
+         *         vértice, los descendientes de ambos son recursivamente iguales, y los
+         *         colores son iguales; <code>false</code> en otro caso.
          */
-        @Override public boolean equals(Object objeto) {
+        @Override
+        public boolean equals(Object objeto) {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked")
-                VerticeRojinegro vertice = (VerticeRojinegro)objeto;
-            // Aquí va su código.
+            VerticeRojinegro vertice = (VerticeRojinegro) objeto;
+            return (color == vertice.color && super.equals(objeto));
         }
     }
 
     /**
-     * Constructor sin parámetros. Para no perder el constructor sin parámetros
-     * de {@link ArbolBinarioOrdenado}.
+     * Constructor sin parámetros. Para no perder el constructor sin parámetros de
+     * {@link ArbolBinarioOrdenado}.
      */
-    public ArbolRojinegro() { super(); }
+    public ArbolRojinegro() {
+        super();
+    }
 
     /**
-     * Construye un árbol rojinegro a partir de una colección. El árbol
-     * rojinegro tiene los mismos elementos que la colección recibida.
-     * @param coleccion la colección a partir de la cual creamos el árbol
-     *        rojinegro.
+     * Construye un árbol rojinegro a partir de una colección. El árbol rojinegro
+     * tiene los mismos elementos que la colección recibida.
+     * 
+     * @param coleccion la colección a partir de la cual creamos el árbol rojinegro.
      */
     public ArbolRojinegro(Coleccion<T> coleccion) {
         super(coleccion);
     }
 
     /**
-     * Construye un nuevo vértice, usando una instancia de {@link
-     * VerticeRojinegro}.
+     * Construye un nuevo vértice, usando una instancia de {@link VerticeRojinegro}.
+     * 
      * @param elemento el elemento dentro del vértice.
      * @return un nuevo vértice rojinegro con el elemento recibido dentro del mismo.
      */
-    @Override protected Vertice nuevoVertice(T elemento) {
+    @Override
+    protected Vertice nuevoVertice(T elemento) {
         return new VerticeRojinegro(elemento);
     }
 
     /**
      * Regresa el color del vértice rojinegro.
+     * 
      * @param vertice el vértice del que queremos el color.
      * @return el color del vértice rojinegro.
-     * @throws ClassCastException si el vértice no es instancia de {@link
-     *         VerticeRojinegro}.
+     * @throws ClassCastException si el vértice no es instancia de
+     *                            {@link VerticeRojinegro}.
      */
     public Color getColor(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        VerticeRojinegro v = (VerticeRojinegro) vertice;
+        return v.color;
+    }
+
+    /**
+     * Regresa true si el vertice existe y es rojo, null en otro caso.
+     */
+    private boolean esRojo(VerticeRojinegro vertice) {
+        return (vertice != null && vertice.color == Color.ROJO);
+    }
+
+    /**
+     * Regresa true si el vertice es negro.
+     */
+    private boolean esNegro(VerticeRojinegro vertice) {
+        if (vertice == null)
+            return true;
+        return vertice.elemento == null || vertice.color == Color.NEGRO;
+    }
+
+    /**
+     * Método que convierte un VerticeArbolBinario en un Vertice rojinegro.
+     * 
+     * @return El verticerojinegro
+     */
+    private VerticeRojinegro verticeRojinegro(VerticeArbolBinario<T> vertice) {
+        VerticeRojinegro v = (VerticeRojinegro) vertice;
+        return v;
     }
 
     /**
-     * Agrega un nuevo elemento al árbol. El método invoca al método {@link
-     * ArbolBinarioOrdenado#agrega}, y después balancea el árbol recoloreando
+     * Agrega un nuevo elemento al árbol. El método invoca al método
+     * {@link ArbolBinarioOrdenado#agrega}, y después balancea el árbol recoloreando
      * vértices y girando el árbol como sea necesario.
+     * 
      * @param elemento el elemento a agregar.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override
+    public void agrega(T elemento) {
+        super.agrega(elemento);
+        Vertice vertice = super.ultimoAgregado;
+        VerticeArbolBinario<T> aux = (VerticeArbolBinario<T>) vertice;
+        VerticeRojinegro v = (VerticeRojinegro) aux;
+        v.color = Color.ROJO;
+        agrega(v);
+    }
+
+    private void agrega(VerticeRojinegro hijo) {
+        // Caso 1
+        if (!hijo.hayPadre()) {
+            hijo.color = Color.NEGRO;
+            return;
+        }
+        // Caso 2
+        VerticeRojinegro padre = (VerticeRojinegro) hijo.padre();
+        if (!esRojo(padre))
+            return;
+        // Caso 3 El padre es rojo y el abuelo es != null
+        VerticeRojinegro abuelo = (VerticeRojinegro) padre.padre();
+        // Encontramos al tio
+        VerticeRojinegro tio = null;
+        if (abuelo.izquierdo == padre && abuelo.hayDerecho()) {
+            tio = (VerticeRojinegro) abuelo.derecho();
+        } else if (abuelo.derecho == padre && abuelo.hayIzquierdo()) {
+            tio = (VerticeRojinegro) abuelo.izquierdo();
+        }
+        if (esRojo(tio)) {
+            tio.color = Color.NEGRO;
+            padre.color = Color.NEGRO;
+            abuelo.color = Color.ROJO;
+            agrega(abuelo);
+            return;
+        }
+        // Caso 4 El tio existe y es NEGRO
+        // El hijo está cruzado con su abuelo?
+        VerticeRojinegro aux;
+        if (abuelo.izquierdo == padre && padre.derecho == hijo) {
+            super.giraIzquierda(padre);
+            aux = padre;
+            padre = hijo;
+            hijo = aux;
+        } else if (abuelo.derecho == padre && padre.izquierdo == hijo) {
+            super.giraDerecha(padre);
+            aux = padre;
+            padre = hijo;
+            hijo = aux;
+        }
+
+        // Caso 5
+        padre.color = Color.NEGRO;
+        abuelo.color = Color.ROJO;
+        if (abuelo.izquierdo == padre) {
+            super.giraDerecha(abuelo);
+        } else if (abuelo.derecho == padre) {
+            super.giraIzquierda(abuelo);
+        }
     }
 
     /**
-     * Elimina un elemento del árbol. El método elimina el vértice que contiene
-     * el elemento, y recolorea y gira el árbol como sea necesario para
-     * rebalancearlo.
+     * Elimina un elemento del árbol. El método elimina el vértice que contiene el
+     * elemento, y recolorea y gira el árbol como sea necesario para rebalancearlo.
+     * 
      * @param elemento el elemento a eliminar del árbol.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override
+    public void elimina(T elemento) {
+        VerticeRojinegro v = verticeRojinegro(busca(elemento));
+        if (v == null)
+            return;
+
+        // Si tiene 2 hijos
+        if (v.hayIzquierdo() && v.hayDerecho()) {
+            v = dosHijos(v);
+        } else if (!v.hayIzquierdo() && !v.hayDerecho()) {
+            pegaFantasma(v);
+        }
+
+        this.elementos--;
+
+        VerticeRojinegro h = hijo(v);
+
+        super.eliminaVertice(v);
+
+        if (esRojo(h) && esNegro(v)) {
+            h.color = Color.NEGRO;
+            return;
+        }
+
+        if (esRojo(v) && esNegro(h)) {
+            eliminaFantasma(h);
+            return;
+        }
+
+        if (esNegro(v) && esNegro(h)) {
+            rebalanceo(h);
+        }
+
+        eliminaFantasma(h);
+
+    }
+
+    private void pegaFantasma(VerticeRojinegro v) {
+        VerticeRojinegro fantasma = verticeRojinegro(nuevoVertice(null));
+        fantasma.padre = v;
+        v.izquierdo = fantasma;
+        fantasma.color = Color.NEGRO;
+    }
+
+    /**
+     * 
+     */
+    private void eliminaFantasma(VerticeRojinegro v) {
+        if (v.elemento != null)
+            return;
+        if (v.padre == null) {
+            limpia();
+            return;
+        }
+        VerticeRojinegro padre = verticeRojinegro(v.padre());
+        v.padre = null;
+        if (padre.izquierdo == v) {
+            padre.izquierdo = null;
+        } else if (padre.derecho == v) {
+            padre.derecho = null;
+        }
+    }
+
+    /**
+     * Devuelve el vertice hijo de un vertice con un único hijo
+     */
+    private VerticeRojinegro hijo(VerticeRojinegro v) {
+        if (v.hayIzquierdo()) {
+            return verticeRojinegro(v.izquierdo());
+        } else if (v.hayDerecho()) {
+            return verticeRojinegro(v.derecho());
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Metodo que devuelve un vertice con exactamente un hijo
+     */
+    private VerticeRojinegro dosHijos(VerticeRojinegro v) {
+        VerticeRojinegro fantasma = verticeRojinegro(nuevoVertice(null));
+        v = verticeRojinegro(super.intercambiaEliminable(v));
+        if (!v.hayDerecho() && !v.hayIzquierdo()) {
+            fantasma.padre = v;
+            v.izquierdo = fantasma;
+            fantasma.color = Color.NEGRO;
+        }
+        return v;
+    }
+
+    /**
+     * Rebalancea el arbol
+     */
+    private void rebalanceo(VerticeRojinegro v) {
+        if (v == null)
+            return;
+
+        // Caso 1
+        if (v.padre == null) {
+            v.color = Color.NEGRO;
+            return;
+        }
+
+        VerticeRojinegro padre = verticeRojinegro(v.padre);
+        VerticeRojinegro hermano;
+        boolean giro; // True si gira izquierda, false derecha
+        if (padre.izquierdo == v) {
+            hermano = verticeRojinegro(padre.derecho);
+            giro = true;
+        } else {
+            hermano = verticeRojinegro(padre.izquierdo);
+            giro = false;
+        }
+
+        // Caso 2
+        if (hermano.color == Color.ROJO) {
+            padre.color = Color.ROJO;
+            hermano.color = Color.NEGRO;
+            if (giro) {
+                super.giraIzquierda(padre);
+            } else {
+                super.giraDerecha(padre);
+            }
+        }
+
+        if (padre.izquierdo == v) {
+            hermano = verticeRojinegro(padre.derecho);
+        } else {
+            hermano = verticeRojinegro(padre.izquierdo);
+        }
+
+        // Caso 3
+        VerticeRojinegro hi = verticeRojinegro(hermano.izquierdo);
+        VerticeRojinegro hd = verticeRojinegro(hermano.derecho);
+
+        if (esNegro(padre) && esNegro(hermano) && esNegro(hi) && esNegro(hd)) {
+            hermano.color = Color.ROJO;
+            rebalanceo(padre);
+            return;
+        }
+
+        // Caso 4
+        if (esRojo(padre) && esNegro(hermano) && esNegro(hi) && esNegro(hd)) {
+            hermano.color = Color.ROJO;
+            padre.color = Color.NEGRO;
+            return;
+        }
+
+        // Caso 5
+        if ((giro && esRojo(hi) && esNegro(hd)) || (!giro && esNegro(hi) && esRojo(hd))) {
+            hermano.color = Color.ROJO;
+            if (esRojo(hi)) {
+                hi.color = Color.NEGRO;
+            } else {
+                hd.color = Color.NEGRO;
+            }
+
+            if (giro) {
+                super.giraDerecha(hermano);
+            } else {
+                super.giraIzquierda(hermano);
+            }
+
+        }
+
+        if (padre.izquierdo() == v) {
+            hermano = verticeRojinegro(padre.derecho());
+        } else {
+            hermano = verticeRojinegro(padre.izquierdo());
+        }
+
+        hi = verticeRojinegro(hermano.izquierdo);
+        hd = verticeRojinegro(hermano.derecho);
+
+        // Caso 6
+        if ((giro && esRojo(hd)) || !giro && esRojo(hi)) {
+            hermano.color = padre.color;
+            padre.color = Color.NEGRO;
+
+            if (giro) {
+                hd.color = Color.NEGRO;
+                super.giraIzquierda(padre);
+            } else {
+                hi.color = Color.NEGRO;
+                super.giraDerecha(padre);
+            }
+        }
     }
 
     /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles
-     * rojinegros no pueden ser girados a la izquierda por los usuarios de la
-     * clase, porque se desbalancean.
+     * rojinegros no pueden ser girados a la izquierda por los usuarios de la clase,
+     * porque se desbalancean.
+     * 
      * @param vertice el vértice sobre el que se quiere girar.
      * @throws UnsupportedOperationException siempre.
      */
-    @Override public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        throw new UnsupportedOperationException("Los árboles rojinegros no " +
-                                                "pueden girar a la izquierda " +
-                                                "por el usuario.");
+    @Override
+    public void giraIzquierda(VerticeArbolBinario<T> vertice) {
+        throw new UnsupportedOperationException(
+                "Los árboles rojinegros no " + "pueden girar a la izquierda " + "por el usuario.");
     }
 
     /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles
-     * rojinegros no pueden ser girados a la derecha por los usuarios de la
-     * clase, porque se desbalancean.
+     * rojinegros no pueden ser girados a la derecha por los usuarios de la clase,
+     * porque se desbalancean.
+     * 
      * @param vertice el vértice sobre el que se quiere girar.
      * @throws UnsupportedOperationException siempre.
      */
-    @Override public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        throw new UnsupportedOperationException("Los árboles rojinegros no " +
-                                                "pueden girar a la derecha " +
-                                                "por el usuario.");
+    @Override
+    public void giraDerecha(VerticeArbolBinario<T> vertice) {
+        throw new UnsupportedOperationException(
+                "Los árboles rojinegros no " + "pueden girar a la derecha " + "por el usuario.");
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..38f313b 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -16,18 +16,40 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordenar el arreglo.
      */
-    public static <T> void
-    quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void quickSort(T[] arreglo, Comparator<T> comparador) {
+        quickSort(arreglo, 0, arreglo.length - 1, comparador);
+    }
+
+    
+    private static <T> void quickSort(T[] arreglo, int a, int b, Comparator<T> comparador) {
+        if (b <= a)
+            return;
+        int i = a + 1;
+        int j = b;
+        while (i < j) {
+            if ((comparador.compare(arreglo[i], arreglo[a]) > 0) && (comparador.compare(arreglo[j], arreglo[a])) <= 0) {
+                intercambia(arreglo, i, j);
+                i++;
+                j--;
+            } else if ((comparador.compare(arreglo[i], arreglo[a])) <= 0)
+                i++;
+            else
+                j--;
+        }
+        if (comparador.compare(arreglo[i], arreglo[a]) > 0) {
+            i--;
+        }
+        intercambia(arreglo, a, i);
+        quickSort(arreglo, a, i - 1, comparador);
+        quickSort(arreglo, i + 1, b, comparador);
     }
 
     /**
-     * Ordena el arreglo recibido usando QickSort.
+     * Ordena el arreglo recibido usando QuickSort.
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    quickSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void quickSort(T[] arreglo) {
         quickSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -37,9 +59,17 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordernar el arreglo.
      */
-    public static <T> void
-    selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> void selectionSort(T[] arreglo, Comparator<T> comparador) {
+        int m = 0;
+        for (int i = 0; i < arreglo.length; i++) {
+            m = i;
+            for (int j = i + 1; j < arreglo.length; j++) {
+                if ((comparador.compare(arreglo[j], arreglo[m])) < 0) {
+                    m = j;
+                }
+            }
+            intercambia(arreglo, i, m);
+        }
     }
 
     /**
@@ -47,8 +77,7 @@ public class Arreglos {
      * @param <T> tipo del que puede ser el arreglo.
      * @param arreglo un arreglo cuyos elementos son comparables.
      */
-    public static <T extends Comparable<T>> void
-    selectionSort(T[] arreglo) {
+    public static <T extends Comparable<T>> void selectionSort(T[] arreglo) {
         selectionSort(arreglo, (a, b) -> a.compareTo(b));
     }
 
@@ -61,9 +90,36 @@ public class Arreglos {
      * @param comparador el comparador para hacer la búsqueda.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T> int
-    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+    public static <T> int busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
+        return busquedaBinaria(0, arreglo.length - 1, arreglo, elemento, comparador);
+    }
+
+    /**
+     * Método auxiliar que parte el arreglo en 2 hasta encontrar el indice del
+     * elemento
+     * 
+     * @param init       Indice inicial del arreglo o del subarreglo
+     * @param fin        Indice final del arreglo o del subarreglo
+     * @param arreglo    El arreglo al que se le aplica la busqueda
+     * @param elemento   Elemento a buscar en el arreglo
+     * @param comparador Objeto que se usa para comparar los elementos internos del
+     *                   arreglo
+     * @return El indice del elemento en el arreglo o -1 si no se encuentra
+     */
+    private static <T> int busquedaBinaria(int init, int fin, T[] arreglo, T elemento, Comparator<T> comparador) {
+        int m = init + ((fin - init) / 2);
+        if (fin - init == 0)
+            return -1;
+        if (comparador.compare(elemento, arreglo[init]) == 0)
+            return init;
+        if (comparador.compare(elemento, arreglo[fin]) == 0)
+            return fin;
+        if (comparador.compare(elemento, arreglo[m]) == 0)
+            return m;
+        if (comparador.compare(elemento, arreglo[m]) > 0)
+            return busquedaBinaria(m + 1, fin, arreglo, elemento, comparador);
+        else
+            return busquedaBinaria(init, m, arreglo, elemento, comparador);
     }
 
     /**
@@ -74,8 +130,20 @@ public class Arreglos {
      * @param elemento el elemento a buscar.
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
-    public static <T extends Comparable<T>> int
-    busquedaBinaria(T[] arreglo, T elemento) {
+    public static <T extends Comparable<T>> int busquedaBinaria(T[] arreglo, T elemento) {
         return busquedaBinaria(arreglo, elemento, (a, b) -> a.compareTo(b));
     }
+
+    /**
+     * Intercambia los elemento del primer indice con el segundo.
+     * 
+     * @param arreglo Arreglo de tipo generico
+     * @param a       Primer indice
+     * @param b       Segundo indice
+     */
+    private static <T> void intercambia(T[] arreglo, int a, int b) {
+        T aux = arreglo[a];
+        arreglo[a] = arreglo[b];
+        arreglo[b] = aux;
+    }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..b4904a5 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -10,7 +10,13 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String res = "";
+        Nodo aux = cabeza;
+        while (aux != null) {
+            res = res + aux.elemento + ",";
+            aux = aux.siguiente;
+        }
+        return res;
     }
 
     /**
@@ -20,6 +26,15 @@ public class Cola<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        if (rabo == null) {
+            cabeza = n;
+            rabo = n;
+        } else {
+            rabo.siguiente = n;
+            rabo = n;
+        }
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index b84a155..057b89a 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,7 +28,9 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            anterior = null;
+            siguiente = null;
         }
     }
 
@@ -41,37 +43,48 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
-            // Aquí va su código.
+            anterior = null;
+            siguiente = cabeza;
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return siguiente != null;
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
-            // Aquí va su código.
+            if (!hasNext())
+                throw new NoSuchElementException();
+            this.anterior = this.siguiente;
+            this.siguiente = this.siguiente.siguiente;
+            return this.anterior.elemento;
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return anterior != null;
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
-            // Aquí va su código.
+            if (!hasPrevious())
+                throw new NoSuchElementException();
+            this.siguiente = this.anterior;
+            this.anterior = this.anterior.anterior;
+            return this.siguiente.elemento;
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            anterior = null;
+            siguiente = cabeza;
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            siguiente = null;
+            anterior = rabo;
         }
     }
 
@@ -88,7 +101,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -97,7 +110,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return longitud;
     }
 
     /**
@@ -106,7 +119,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -118,7 +131,18 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) { // La cabeza y el rabo son el mismo nodo
+            this.cabeza = n;
+            this.rabo = n;
+        } else { // Agrega un nodo después del rabo y actualiza el rabo a ese nodo
+            n.anterior = this.rabo;
+            this.rabo.siguiente = n;
+            this.rabo = n;
+        }
     }
 
     /**
@@ -129,7 +153,19 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) {
+            this.cabeza = n;
+            this.rabo = n;
+        } else {
+            n.anterior = this.rabo;
+            this.rabo.siguiente = n;
+            this.rabo = n;
+        }
     }
 
     /**
@@ -140,7 +176,18 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        longitud++;
+        if (esVacia()) {
+            this.cabeza = n;
+            this.rabo = n;
+        } else { // Agrega un elemento antes de la cabeza y actualiza la cabeza
+            n.siguiente = this.cabeza;
+            this.cabeza.anterior = n;
+            this.cabeza = n;
+        }
     }
 
     /**
@@ -159,7 +206,41 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        } else if (i < 1) {
+            agregaInicio(elemento);
+        } else if (i > this.longitud - 1) {
+            agregaFinal(elemento);
+        } else {
+            if (0 < i && i <= longitud - 1) { // Se asegura otra vez que el indice esté
+                longitud++; // dentro del rango
+                Nodo s = iesimoNodo(i); // Nodo iesimo el cual va a ser el siguiente nodo del nuevo
+                Nodo n = new Nodo(elemento); // Nodo a agregar a la lista
+                Nodo a = s.anterior; // Nodo anterior al iesimo
+                n.anterior = a;
+                a.siguiente = n; // Agrega el nodo nuevo entre el s y el a
+                n.siguiente = s;
+                s.anterior = n;
+            }
+
+        }
+    }
+
+    /**
+     * Busca el nodo dado un indice
+     * 
+     * @param i Indice del nodo requerido
+     * @return El i-esimo nodo
+     */
+    public Nodo iesimoNodo(int i) {
+        Nodo aux = cabeza;
+        if (0 <= i && i <= longitud - 1) { // Se vuelve a asegurar que el indice se
+            for (int j = 0; j < i; j++) { // encuentre dentro del rango.
+                aux = aux.siguiente; // Recorre la lista hasta el iesimo nodo
+            }
+        }
+        return aux;
     }
 
     /**
@@ -168,7 +249,25 @@ public class Lista<T> implements Coleccion<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (elemento == null || !contiene(elemento))
+            return;
+        if (cabeza.elemento.equals(elemento)) {
+            eliminaPrimero(); // Si el primer elemento es la cabeza elimina la cabeza
+            return;
+        }
+        if (contiene(elemento)) { // Si el elemento esta contenido en la lista:
+            Nodo aux = cabeza;
+            for (int i = 0; i < longitud - 2; i++) { // Recorre la lista hasta el penultimo elemento
+                if (aux.elemento.equals(elemento)) { // Encuentra el elemento recorrido con el
+                    aux.anterior.siguiente = aux.siguiente; // pasado como parametro
+                    aux.siguiente.anterior = aux.anterior; // elimina el nodo
+                    longitud--;
+                    return;
+                }
+                aux = aux.siguiente;
+            }
+            eliminaUltimo(); // Sino elimina el ultimo elemento
+        }
     }
 
     /**
@@ -177,7 +276,21 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
-        // Aquí va su código.
+        Nodo n = cabeza;
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        } else if (longitud == 1) { // La lista vacia
+            cabeza = null;
+            rabo = null;
+        } else if (longitud == 2) { // La lista con un elemento
+            cabeza = rabo;
+            rabo.anterior = null;
+        } else {
+            cabeza = cabeza.siguiente; // Elimina la cabeza y la actualiza.
+            cabeza.anterior = null;
+        }
+        this.longitud--;
+        return n.elemento;
     }
 
     /**
@@ -186,7 +299,21 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
-        // Aquí va su código.
+        Nodo n = rabo;
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        } else if (longitud == 1) { // La lista vacia
+            cabeza = null;
+            rabo = null;
+        } else if (longitud == 2) { // La lista con un elemento
+            rabo = cabeza;
+            cabeza.siguiente = null;
+        } else {
+            rabo = rabo.anterior; // Elimina el rabo y lo actualiza
+            rabo.siguiente = null;
+        }
+        this.longitud--;
+        return n.elemento;
     }
 
     /**
@@ -196,7 +323,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {// Recorre la lista en busca de un
+            if (aux.elemento.equals(elemento)) { // nodo con el mismo elemento
+                return true;
+            }
+            aux = aux.siguiente;
+        }
+        return false;
     }
 
     /**
@@ -204,7 +341,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> rev = new Lista<T>();
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) { // Añade los nuevos elementos
+            rev.agregaInicio(aux.elemento); // al principio
+            aux = aux.siguiente;
+        }
+        return rev;
     }
 
     /**
@@ -213,14 +356,22 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
-        // Aquí va su código.
+        Lista<T> copy = new Lista<T>();
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) { // Recorre la lista y conforme la recorre
+            copy.agrega(aux.elemento); // agrega los elementos a la nueva lista
+            aux = aux.siguiente;
+        }
+        return copy;
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        this.cabeza = null;
+        this.rabo = null;
+        this.longitud = 0;
     }
 
     /**
@@ -229,7 +380,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
-        // Aquí va su código.
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        }
+        return this.cabeza.elemento;
     }
 
     /**
@@ -238,7 +392,10 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
-        // Aquí va su código.
+        if (esVacia()) {
+            throw new NoSuchElementException();
+        }
+        return this.rabo.elemento;
     }
 
     /**
@@ -249,7 +406,17 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if (i >= longitud || i < 0) {
+            throw new ExcepcionIndiceInvalido();
+        }
+        Nodo aux = cabeza; // Recorre la lista hasta que el indice buscado sea
+        for (int j = 0; j < longitud; j++) { // igual al nodo recorrido
+            if (j == i) {
+                break;
+            }
+            aux = aux.siguiente;
+        }
+        return aux.elemento;
     }
 
     /**
@@ -259,7 +426,17 @@ public class Lista<T> implements Coleccion<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        if (elemento == null) {
+            throw new IllegalArgumentException();
+        }
+        Nodo n = cabeza;
+        for (int i = 0; i < longitud; i++) { // Recorre la lista, la cantidad de veces necesaria
+            if (elemento.equals(n.elemento)) { // hasta encontrar el elemento y regresa el indice
+                return i;
+            }
+            n = n.siguiente;
+        }
+        return -1; // Si no lo encuentra regresa -1
     }
 
     /**
@@ -267,7 +444,20 @@ public class Lista<T> implements Coleccion<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if (longitud == 0) {
+            return "[]"; // La lista vacia
+        }
+        String res = "[";
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {
+            if (i == longitud - 1) {
+                res = res + aux.elemento + "]"; // Si es el ultimo elemento
+            } else {
+                res = res + aux.elemento + ", "; // Si es la cabeza o algun elemento
+                aux = aux.siguiente; // intermedio
+            }
+        }
+        return res;
     }
 
     /**
@@ -280,7 +470,15 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
+        if (lista.longitud != this.longitud) // Una lista es igual a otra si tiene la misma
+            return false; // longitud
+        Nodo aux = this.cabeza;
+        for (int i = 0; aux != null; i++) { // Recorre nodo con nodo y compara
+            if (!aux.elemento.equals(lista.get(i))) // elemento a elemento
+                return false;
+            aux = aux.siguiente;
+        }
+        return true;
     }
 
     /**
@@ -308,7 +506,56 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+        if (this.longitud == 1 || this.longitud == 0) {
+            return copia();
+        }
+        Lista<T> l1 = new Lista<>();
+        Lista<T> l2 = new Lista<>();
+
+        // Agregando elementos a la lista
+        for (int i = 0; i < this.longitud / 2; i++) {
+            l1.agrega(get(i));
+        }
+        for (int i = this.longitud / 2; i < this.longitud; i++) {
+            l2.agrega(get(i));
+        }
+
+        l1 = l1.mergeSort(comparador);
+        l2 = l2.mergeSort(comparador);
+        return mezcla(l1, l2, comparador);
+    }
+
+    /**
+     * Método auxiliar que mezcla 2 listas y las va ordenando en una nueva
+     * 
+     * @param lista1 Lista a ordenar
+     * @param lista2 Lista a ordenar
+     * @return La lista con los elementos ordenados de ambas listas
+     */
+    public Lista<T> mezcla(Lista<T> lista1, Lista<T> lista2, Comparator<T> comparador) {
+        Nodo i = lista1.cabeza;
+        Nodo j = lista2.cabeza;
+        Lista<T> lista = new Lista<T>();
+        while (i != null && j != null) {
+            if (comparador.compare(i.elemento, j.elemento) <= 0) {
+                lista.agrega(i.elemento);
+                i = i.siguiente;
+            } else {
+                lista.agrega(j.elemento);
+                j = j.siguiente;
+            }
+        }
+        if (i == null)
+            while (j != null) {
+                lista.agrega(j.elemento);
+                j = j.siguiente;
+            }
+        if (j == null)
+            while (i != null) {
+                lista.agrega(i.elemento);
+                i = i.siguiente;
+            }
+        return lista;
     }
 
     /**
@@ -333,7 +580,14 @@ public class Lista<T> implements Coleccion<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+        Nodo aux = cabeza;
+        for (int i = 0; i < longitud; i++) {// Recorre la lista en busca de un
+            if ((comparador.compare(elemento, aux.elemento)) == 0) { // nodo con el mismo elemento
+                return true;
+            }
+            aux = aux.siguiente;
+        }
+        return false;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index c4206b0..5339206 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,7 +22,8 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            siguiente = null;
         }
     }
 
@@ -43,7 +44,14 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T saca() {
-        // Aquí va su código.
+        Nodo a = cabeza;
+        if (cabeza == null)
+            throw new NoSuchElementException();
+        cabeza = cabeza.siguiente;
+        if (cabeza == null) {
+            rabo = null;
+        }
+        return a.elemento;
     }
 
     /**
@@ -53,7 +61,11 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T mira() {
-        // Aquí va su código.
+        if (cabeza == null) {
+            throw new NoSuchElementException();
+        } else {
+            return cabeza.elemento;
+        }
     }
 
     /**
@@ -62,7 +74,7 @@ public abstract class MeteSaca<T> {
      *         <tt>false</tt> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -76,6 +88,30 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
+        Nodo auxClase = cabeza;
+        Nodo auxListaM = m.cabeza;
+        if (esVacia() && m.esVacia())
+            return true;
+        int i = 0;
+        while (auxClase != null) {
+            auxClase = auxClase.siguiente;
+            i++;
+        }
+        int j = 0;
+        while (auxListaM != null) {
+            auxListaM = auxListaM.siguiente;
+            j++;
+        }
+        if (i != j)
+            return false;
+        Nodo aux = cabeza;
+        Nodo auxM = m.cabeza;
+        while (aux != null) {
+            if (!aux.elemento.equals(auxM.elemento))
+                return false;
+            aux = aux.siguiente;
+            auxM = auxM.siguiente;
+        }
+        return true;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..87f5bba 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -10,7 +10,13 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String res = "";
+        Nodo aux = cabeza;
+        while (aux != null) {
+            res = res + aux.elemento + "\n";
+            aux = aux.siguiente;
+        }
+        return res;
     }
 
     /**
@@ -20,6 +26,15 @@ public class Pila<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Nodo n = new Nodo(elemento);
+        if (cabeza == null) {
+            cabeza = n;
+            rabo = n;
+        } else {
+            n.siguiente = cabeza;
+            cabeza = n;
+        }
     }
 }
diff --git a/src/test/java/mx/unam/ciencias/edd/test/TestArbolRojinegro.java b/src/test/java/mx/unam/ciencias/edd/test/TestArbolRojinegro.java
index 46c83fd..092d2b8 100644
--- a/src/test/java/mx/unam/ciencias/edd/test/TestArbolRojinegro.java
+++ b/src/test/java/mx/unam/ciencias/edd/test/TestArbolRojinegro.java
@@ -19,7 +19,8 @@ import org.junit.rules.Timeout;
 public class TestArbolRojinegro {
 
     /** Expiración para que ninguna prueba tarde más de 5 segundos. */
-    @Rule public Timeout expiracion = Timeout.seconds(5);
+    @Rule
+    public Timeout expiracion = Timeout.seconds(5);
 
     /* Generador de números aleatorios. */
     private Random random;
@@ -28,11 +29,11 @@ public class TestArbolRojinegro {
     /* El árbol. */
     private ArbolRojinegro<Integer> arbol;
 
-    /* Valida el vértice de un árbol rojinegro, y recursivamente
-     * revisa sus hijos. */
-    private static <T extends Comparable<T>> void
-    arbolRojinegroValido(ArbolRojinegro<T> arbol,
-                         VerticeArbolBinario<T> v) {
+    /*
+     * Valida el vértice de un árbol rojinegro, y recursivamente revisa sus hijos.
+     */
+    private static <T extends Comparable<T>> void arbolRojinegroValido(ArbolRojinegro<T> arbol,
+            VerticeArbolBinario<T> v) {
         switch (arbol.getColor(v)) {
         case NEGRO:
             if (v.hayIzquierdo())
@@ -57,11 +58,11 @@ public class TestArbolRojinegro {
         }
     }
 
-    /* Valida que los caminos del vértice a sus hojas tengan todos
-       el mismo número de vértices negros. */
-    private static <T extends Comparable<T>> int
-    validaCaminos(ArbolRojinegro<T> arbol,
-                  VerticeArbolBinario<T> v) {
+    /*
+     * Valida que los caminos del vértice a sus hojas tengan todos el mismo número
+     * de vértices negros.
+     */
+    private static <T extends Comparable<T>> int validaCaminos(ArbolRojinegro<T> arbol, VerticeArbolBinario<T> v) {
         int ni = -1, nd = -1;
         if (v.hayIzquierdo()) {
             VerticeArbolBinario<T> i = v.izquierdo();
@@ -90,13 +91,13 @@ public class TestArbolRojinegro {
 
     /**
      * Valida un árbol rojinegro. Comprueba que la raíz sea negra, que las hojas
-     * sean negras, que un vértice rojo tenga dos hijos negros, y que todo
-     * camino de la raíz a sus hojas tiene el mismo número de vértices negros.
-     * @param <T> tipo del que puede ser el árbol rojinegro.
+     * sean negras, que un vértice rojo tenga dos hijos negros, y que todo camino de
+     * la raíz a sus hojas tiene el mismo número de vértices negros.
+     * 
+     * @param <T>   tipo del que puede ser el árbol rojinegro.
      * @param arbol el árbol a revisar.
      */
-    public static <T extends Comparable<T>> void
-    arbolRojinegroValido(ArbolRojinegro<T> arbol) {
+    public static <T extends Comparable<T>> void arbolRojinegroValido(ArbolRojinegro<T> arbol) {
         if (arbol.esVacia())
             return;
         TestArbolBinarioOrdenado.arbolBinarioOrdenadoValido(arbol);
@@ -118,7 +119,8 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#ArbolRojinegro()}.
      */
-    @Test public void testConstructor() {
+    @Test
+    public void testConstructor() {
         Assert.assertTrue(arbol.esVacia());
         Assert.assertTrue(arbol.getElementos() == 0);
     }
@@ -126,7 +128,8 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#ArbolRojinegro(Coleccion)}.
      */
-    @Test public void testConstructorColeccion() {
+    @Test
+    public void testConstructorColeccion() {
         Lista<Integer> lista = new Lista<Integer>();
         for (int i = 0; i < total; i++)
             lista.agrega(random.nextInt(total));
@@ -153,9 +156,7 @@ public class TestArbolRojinegro {
     private void testAgregaCaso2A() {
         arbol.agrega(2);
         String s = arbol.toString();
-        String t =
-            "N{1}\n" +
-            "└─»R{2}\n";
+        String t = "N{1}\n" + "└─»R{2}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -163,10 +164,7 @@ public class TestArbolRojinegro {
     private void testAgregaCaso2B() {
         arbol.agrega(0);
         String s = arbol.toString();
-        String t =
-            "N{1}\n" +
-            "├─›R{0}\n" +
-            "└─»R{2}\n";
+        String t = "N{1}\n" + "├─›R{0}\n" + "└─»R{2}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -174,11 +172,7 @@ public class TestArbolRojinegro {
     private void testAgregaCaso3() {
         arbol.agrega(4);
         String s = arbol.toString();
-        String t =
-            "N{1}\n" +
-            "├─›N{0}\n" +
-            "└─»N{2}\n" +
-            "   └─»R{4}\n";
+        String t = "N{1}\n" + "├─›N{0}\n" + "└─»N{2}\n" + "   └─»R{4}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -186,12 +180,7 @@ public class TestArbolRojinegro {
     private void testAgregaCaso4() {
         arbol.agrega(3);
         String s = arbol.toString();
-        String t =
-            "N{1}\n" +
-            "├─›N{0}\n" +
-            "└─»N{3}\n" +
-            "   ├─›R{2}\n" +
-            "   └─»R{4}\n";
+        String t = "N{1}\n" + "├─›N{0}\n" + "└─»N{3}\n" + "   ├─›R{2}\n" + "   └─»R{4}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -199,20 +188,15 @@ public class TestArbolRojinegro {
     private void testAgregaCaso5() {
         arbol.agrega(5);
         String s = arbol.toString();
-        String t =
-            "N{1}\n" +
-            "├─›N{0}\n" +
-            "└─»R{3}\n" +
-            "   ├─›N{2}\n" +
-            "   └─»N{4}\n" +
-            "      └─»R{5}\n";
+        String t = "N{1}\n" + "├─›N{0}\n" + "└─»R{3}\n" + "   ├─›N{2}\n" + "   └─»N{4}\n" + "      └─»R{5}\n";
         Assert.assertTrue(s.equals(t));
     }
 
     /**
      * Prueba unitaria para {@link ArbolRojinegro#agrega}.
      */
-    @Test public void testAgrega() {
+    @Test
+    public void testAgrega() {
         testAgregaCaso1();
         testAgregaCaso2A();
         testAgregaCaso2B();
@@ -223,7 +207,7 @@ public class TestArbolRojinegro {
         for (int i = 0; i < total; i++) {
             int n = random.nextInt(100);
             arbol.agrega(n);
-            Assert.assertTrue(arbol.getElementos() == i+1);
+            Assert.assertTrue(arbol.getElementos() == i + 1);
             VerticeArbolBinario<Integer> it = arbol.busca(n);
             Assert.assertTrue(it != null);
             Assert.assertTrue(it.get() == n);
@@ -277,12 +261,7 @@ public class TestArbolRojinegro {
         arbol.elimina(2);
         arbolRojinegroValido(arbol);
         String s = arbol.toString();
-        String t =
-            "N{4}\n" +
-            "├─›N{1}\n" +
-            "│  └─»R{3}\n" +
-            "└─»N{5}\n" +
-            "   └─»R{6}\n";
+        String t = "N{4}\n" + "├─›N{1}\n" + "│  └─»R{3}\n" + "└─»N{5}\n" + "   └─»R{6}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -294,16 +273,12 @@ public class TestArbolRojinegro {
         arbol.elimina(4);
         arbolRojinegroValido(arbol);
         String s = arbol.toString();
-        String t =
-            "N{2}\n" +
-            "├─›N{1}\n" +
-            "└─»N{3}\n";
+        String t = "N{2}\n" + "├─›N{1}\n" + "└─»N{3}\n";
         Assert.assertTrue(s.equals(t));
         arbol.elimina(1);
         arbolRojinegroValido(arbol);
         s = arbol.toString();
-        t = "N{2}\n" +
-            "└─»R{3}\n";
+        t = "N{2}\n" + "└─»R{3}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -315,20 +290,12 @@ public class TestArbolRojinegro {
         arbol.elimina(3);
         arbolRojinegroValido(arbol);
         String s = arbol.toString();
-        String t =
-            "N{2}\n" +
-            "├─›N{1}\n" +
-            "└─»R{5}\n" +
-            "   ├─›N{4}\n" +
-            "   └─»N{6}\n";
+        String t = "N{2}\n" + "├─›N{1}\n" + "└─»R{5}\n" + "   ├─›N{4}\n" + "   └─»N{6}\n";
         Assert.assertTrue(s.equals(t));
         arbol.elimina(4);
         arbolRojinegroValido(arbol);
         s = arbol.toString();
-        t = "N{2}\n" +
-            "├─›N{1}\n" +
-            "└─»N{5}\n" +
-            "   └─»R{6}\n";
+        t = "N{2}\n" + "├─›N{1}\n" + "└─»N{5}\n" + "   └─»R{6}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -340,18 +307,12 @@ public class TestArbolRojinegro {
         arbol.elimina(5);
         arbolRojinegroValido(arbol);
         String s = arbol.toString();
-        String t =
-            "N{2}\n" + 
-            "├─›N{1}\n" + 
-            "└─»N{4}\n" + 
-            "   └─›R{3}\n";
+        String t = "N{2}\n" + "├─›N{1}\n" + "└─»N{4}\n" + "   └─›R{3}\n";
         Assert.assertTrue(s.equals(t));
         arbol.elimina(1);
         arbolRojinegroValido(arbol);
         s = arbol.toString();
-        t = "N{3}\n" +
-            "├─›N{2}\n" +
-            "└─»N{4}\n";
+        t = "N{3}\n" + "├─›N{2}\n" + "└─»N{4}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -363,18 +324,12 @@ public class TestArbolRojinegro {
         arbol.elimina(1);
         arbolRojinegroValido(arbol);
         String s = arbol.toString();
-        String t =
-            "N{4}\n" +
-            "├─›N{2}\n" +
-            "│  └─»R{3}\n" +
-            "└─»N{5}\n";
+        String t = "N{4}\n" + "├─›N{2}\n" + "│  └─»R{3}\n" + "└─»N{5}\n";
         Assert.assertTrue(s.equals(t));
         arbol.elimina(5);
         arbolRojinegroValido(arbol);
         s = arbol.toString();
-        t = "N{3}\n" +
-            "├─›N{2}\n" +
-            "└─»N{4}\n";
+        t = "N{3}\n" + "├─›N{2}\n" + "└─»N{4}\n";
         Assert.assertTrue(s.equals(t));
     }
 
@@ -410,7 +365,8 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#elimina}.
      */
-    @Test public void testElimina() {
+    @Test
+    public void testElimina() {
         testEliminaNegroRojo();
         testEliminaRojoNegro();
         testEliminaCaso1();
@@ -459,7 +415,8 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#getColor}.
      */
-    @Test public void testGetColor() {
+    @Test
+    public void testGetColor() {
         arbol.agrega(1);
         arbol.agrega(0);
         arbol.agrega(2);
@@ -481,18 +438,21 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#giraIzquierda}.
      */
-    @Test public void testGiraIzquierda() {
+    @Test
+    public void testGiraIzquierda() {
         try {
             arbol.giraIzquierda(null);
             Assert.fail();
-        } catch (UnsupportedOperationException uoe) {}
+        } catch (UnsupportedOperationException uoe) {
+        }
         for (int i = 0; i < total; i++) {
             arbol.agrega(i);
             VerticeArbolBinario<Integer> v = arbol.getUltimoVerticeAgregado();
             try {
                 arbol.giraIzquierda(v);
                 Assert.fail();
-            } catch (UnsupportedOperationException uoe) {}
+            } catch (UnsupportedOperationException uoe) {
+            }
         }
         if (arbol.esVacia())
             return;
@@ -504,7 +464,8 @@ public class TestArbolRojinegro {
             try {
                 arbol.giraIzquierda(v);
                 Assert.fail();
-            } catch (UnsupportedOperationException uoe) {}
+            } catch (UnsupportedOperationException uoe) {
+            }
             if (v.hayIzquierdo())
                 cola.mete(v.izquierdo());
             if (v.hayDerecho())
@@ -515,18 +476,21 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolRojinegro#giraDerecha}.
      */
-    @Test public void testGiraDerecha() {
+    @Test
+    public void testGiraDerecha() {
         try {
             arbol.giraDerecha(null);
             Assert.fail();
-        } catch (UnsupportedOperationException uoe) {}
+        } catch (UnsupportedOperationException uoe) {
+        }
         for (int i = 0; i < total; i++) {
             arbol.agrega(i);
             VerticeArbolBinario<Integer> v = arbol.getUltimoVerticeAgregado();
             try {
                 arbol.giraDerecha(v);
                 Assert.fail();
-            } catch (UnsupportedOperationException uoe) {}
+            } catch (UnsupportedOperationException uoe) {
+            }
         }
         if (arbol.esVacia())
             return;
@@ -538,7 +502,8 @@ public class TestArbolRojinegro {
             try {
                 arbol.giraDerecha(v);
                 Assert.fail();
-            } catch (UnsupportedOperationException uoe) {}
+            } catch (UnsupportedOperationException uoe) {
+            }
             if (v.hayIzquierdo())
                 cola.mete(v.izquierdo());
             if (v.hayDerecho())
@@ -549,7 +514,8 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolBinario#equals}.
      */
-    @Test public void testEquals() {
+    @Test
+    public void testEquals() {
         arbol = new ArbolRojinegro<Integer>();
         ArbolRojinegro<Integer> arbol2 = new ArbolRojinegro<Integer>();
         Assert.assertTrue(arbol.equals(arbol2));
@@ -574,27 +540,20 @@ public class TestArbolRojinegro {
     /**
      * Prueba unitaria para {@link ArbolBinario#toString}.
      */
-    @Test public void testToString() {
+    @Test
+    public void testToString() {
         /* Estoy dispuesto a aceptar una mejor prueba. */
-        Assert.assertTrue(arbol.toString() != null &&
-                          arbol.toString().equals(""));
+        Assert.assertTrue(arbol.toString() != null && arbol.toString().equals(""));
         for (int i = 0; i < total; i++) {
             arbol.agrega(random.nextInt(total));
             arbolRojinegroValido(arbol);
-            Assert.assertTrue(arbol.toString() != null &&
-                              !arbol.toString().equals(""));
+            Assert.assertTrue(arbol.toString() != null && !arbol.toString().equals(""));
         }
         arbol = new ArbolRojinegro<Integer>();
         for (int i = 1; i <= 7; i++)
             arbol.agrega(i);
-        String cadena =
-            "N{2}\n" +
-            "├─›N{1}\n" +
-            "└─»R{4}\n" +
-            "   ├─›N{3}\n" +
-            "   └─»N{6}\n" +
-            "      ├─›R{5}\n" +
-            "      └─»R{7}\n";
+        String cadena = "N{2}\n" + "├─›N{1}\n" + "└─»R{4}\n" + "   ├─›N{3}\n" + "   └─»N{6}\n" + "      ├─›R{5}\n"
+                + "      └─»R{7}\n";
         Assert.assertTrue(arbol.toString().equals(cadena));
     }
 }
